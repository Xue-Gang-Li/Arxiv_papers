
        <!DOCTYPE html>
        <html lang="en">
        <head>
        <meta charset="UTF-8">
        <title>2025-06-13 Arxiv papers related with quantum computing overview</title>
        <style>
        
        body {
            font-family: Arial, sans-serif;
            line-height: 1.6;
            margin: 40px;
            background-color: #f5f5f5;
        }
        .literature-item {
            background-color: white;
            padding: 20px;
            margin-bottom: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }
        h2 {
            color: #333;
            font-size: 24px;
            margin-top: 0;
            padding-bottom: 10px;
            border-bottom: 3px solid #eee;
        }
        .authors {
            color: #666;
            font-style: italic;
            margin-bottom: 15px;
        }
        .summary {
            color: #444;
            text-align: justify;
        }
        .link {
            display: block;
            margin-top: 10px;
            font-size: 14px;
            color: #337ab7;
            text-decoration: none;
        }
        .comment-section {
            margin-top: 10px;
        }
        .comment-input {
            width: 80%;
            padding: 5px;
            margin-right: 5px;
        }
        .comment-button {
            padding: 5px 10px;
        }
        .comment-list {
            list-style-type: none;
            padding: 0;
            margin-top: 5px;
        }
        .comment-list li {
            border: 1px solid #eee;
            padding: 5px;
            margin-bottom: 3px;
        }
        
        </style>
        </head>
        <body>
        <h1>2025-06-13 Arxiv papers related with quantum computing overview</h1>
        
        <h1>Keywords: ['superconducting qubit', 'quantum error correction', 'superconducting circuit', 'surface code', 'transmon', 'quantum parity detection', 'quasiparticle', 'quantum sensor', 'charge parity']</h1>
        

                <div class="literature-item" style="background-color: #fff;">
                <h2>Quantum Speed Limits from Symmetries in Quantum Control</h2>
                <div class="authors">Marco Wiedmann, Daniel Burgarth</div>
                <div class="summary">
                摘要：在量子控制中，量子速度限制为实现某些单元变换提供了基本的下限时间。利用Lie代数方法，我们将这些速度限制与控制哈密顿量的对称性联系起来，并提供了可以计算的定量界限，而无需解决控制系统的动力学。此外，我们特别关注两种场景：一方面是实现给定目标单元变换所需的时间；另一方面是实现目标哈密顿量H在最坏情况下的动力学所需的时间。我们将这些抽象界限应用于耦合量子比特、自旋链、全局控制Rydberg原子和NMR分子等物理系统，并与现有文献进行比较。我们希望我们的结果能帮助实验人员识别瓶颈并设计更快的量子控制系统。
                </div>
                <a href="https://arxiv.org/abs/2506.10069" class="link">https://arxiv.org/abs/2506.10069</a>
                <div class="comment-section">
                    <h3>评论</h3>
                    <input type="text" class="comment-input" id="comment-input-0" placeholder="输入评论">
                    <button class="comment-button" onclick="addComment(0)">提交评论</button>
                    <ul class="comment-list" id="comment-list-0"></ul>
                </div>
                </div>
                
                <div class="literature-item" style="background-color: #fff;">
                <h2>Lieb-Mattis states for robust entangled differential phase sensing</h2>
                <div class="authors">Raphael Kaubruegger, Diego Fallas Padilla, Athreya Shankar, Christoph Hotter, Sean R. Muleady, Jacob Bringewatt, Youcef Baamara, Erfan Abbasgholinejad, Alexey V. Gorshkov, Klaus Mølmer, James K. Thompson, Ana Maria Rey</div>
                <div class="summary">
                摘要：在精密测量科学中，开发能够分辨微妙物理效应的大粒子数N的传感器是一个核心目标。纠缠的量子传感器可以超越标准量子极限（SQL），其中信号方差随1/N缩放，并接近海森堡极限（HL），其方差随1/N²缩放。然而，纠缠态通常对噪声更为敏感，特别是共模噪声，如磁场波动、控制相位噪声或原子干涉仪中的振动。我们提议了一种两节点增强的量子传感器网络，用于微分信号估计，该网络内在地抑制共模噪声，同时对本地非相关噪声具有鲁棒性。此架构能够实现接近海森堡极限的灵敏度。我们研究了两种状态准备策略：（i）类似于玻色两模式压缩的单元纠缠生成，产生海森堡缩放；以及（ii）通过集体发射到共享腔模式实现耗散式准备，提供比SQL更好的√N改进。数值模拟确认，在现实条件下，这两种协议仍然有效，支持在主导共模噪声存在的量子增强传感的可扩展性。
                </div>
                <a href="https://arxiv.org/abs/2506.10151" class="link">https://arxiv.org/abs/2506.10151</a>
                <div class="comment-section">
                    <h3>评论</h3>
                    <input type="text" class="comment-input" id="comment-input-1" placeholder="输入评论">
                    <button class="comment-button" onclick="addComment(1)">提交评论</button>
                    <ul class="comment-list" id="comment-list-1"></ul>
                </div>
                </div>
                
                <div class="literature-item" style="background-color: #fff;">
                <h2>Symmetric quantum states: a review of recent progress</h2>
                <div class="authors">Carlo Marconi, Guillem Müller-Rigat, Jordi Romero-Pallejà, Jordi Tura, Anna Sanpera</div>
                <div class="summary">
                摘要：对称量子态是引人入胜的对象。它们对应于在粒子置换下保持不变的多部体系。这一对称性体现在它们紧凑的数学表征以及独特的物理特性：它们表现出真正的多方纠缠，并具有显著的抗噪声和抗扰动能力。这些特性使得此类态特别适合广泛的量子信息任务。本文对这类态的数学结构和相关物理特性进行了教学分析。在理论框架之外，开发强大的工具以认证和验证对称态在实验环境中的属性至关重要。在这方面，我们探讨了如何针对对称系统调整标准技术，如量子态断层扫描、贝尔测试和纠缠见证。接下来，我们提供了一份关于这些态在特定任务中优于其他态的最相关应用的最新概述。具体来说，我们解决了它们在量子测量中的核心作用，强调了它们在量子误差校正码中的使用，并检查了它们在计算和通信任务中的贡献。最后，我们介绍了它们当前的实验生成状态，从冷原子系统到通过量子算法实现的应用。此外，我们还审查了不同实验实现中最近获得的突破。尽管近年来在对称量子态的表征和应用方面取得了显著进展，但仍有许多有趣的问题未解。本文以讨论一些开放问题并概述未来研究的有望方向结束。
                </div>
                <a href="https://arxiv.org/abs/2506.10185" class="link">https://arxiv.org/abs/2506.10185</a>
                <div class="comment-section">
                    <h3>评论</h3>
                    <input type="text" class="comment-input" id="comment-input-2" placeholder="输入评论">
                    <button class="comment-button" onclick="addComment(2)">提交评论</button>
                    <ul class="comment-list" id="comment-list-2"></ul>
                </div>
                </div>
                
                <div class="literature-item" style="background-color: #fff;">
                <h2>Constructive interference at the edge of quantum ergodic dynamics</h2>
                <div class="authors">Dmitry A. Abanin, Rajeev Acharya, Laleh Aghababaie-Beni, Georg Aigeldinger, Ashok Ajoy, Ross Alcaraz, Igor Aleiner, Trond I. Andersen, Markus Ansmann, Frank Arute, Kunal Arya, Abraham Asfaw, Nikita Astrakhantsev, Juan Atalaya, Ryan Babbush, Dave Bacon, Brian Ballard, Joseph C. Bardin, Christian Bengs, Andreas Bengtsson, Alexander Bilmes, Sergio Boixo, Gina Bortoli, Alexandre Bourassa, Jenna Bovaird, Dylan Bowers, Leon Brill, Michael Broughton, David A. Browne, Brett Buchea, Bob B. Buckley, David A. Buell, Tim Burger, Brian Burkett, Nicholas Bushnell, Anthony Cabrera, Juan Campero, Hung-Shen Chang, Yu Chen, Zijun Chen, Ben Chiaro, Liang-Ying Chih, Desmond Chik, Charina Chou, Jahan Claes, Agnetta Y. Cleland, Josh Cogan, Saul Cohen, Roberto Collins, Paul Conner, William Courtney, Alexander L. Crook, Ben Curtin, Sayan Das, Laura De Lorenzo, Dripto M. Debroy, Sean Demura, Michel Devoret, Agustin Di Paolo, Paul Donohoe, Ilya Drozdov, Andrew Dunsworth, Clint Earle, Alec Eickbusch, Aviv Moshe Elbag, Mahmoud Elzouka, Catherine Erickson, Lara Faoro, Edward Farhi, Vinicius S. Ferreira, Leslie Flores Burgos, Ebrahim Forati, Austin G. Fowler, Brooks Foxen, Suhas Ganjam, Gonzalo Garcia, Robert Gasca, Elie Genois, William Giang, Craig Gidney, Dar Gilboa, Raja Gosula, Alejandro Grajales Dau, Dietrich Graumann, Alex Greene, Jonathan A. Gross, Hanfeng Gu, Steve Habegger, John Hall, Ikko Hamamura, Michael C. Hamilton, Monica Hansen, Matthew P. Harrigan, Sean D. Harrington, Stephen Heslin, Paula Heu, Oscar Higgott, Gordon Hill, Jeremy Hilton, Sabrina Hong</div>
                <div class="summary">
                摘要：量子观测值在以少数点关联器的形式，是描述量子多体系统动力学的关键。在快速生成纠缠的动力学中，由于混乱效应，量子观测值通常会对底层动力学的细节在长时间内变得不敏感。在实验系统中，已成功实施了重复时间反转协议，以恢复量子观测值的灵敏度。使用一个103-量子比特的超导量子处理器，我们通过二阶无序时相关函数（OTOC$^{(2)}$）来表征遍历动力学。与没有时间反转的动力学相比，观察到OTOC$^{(2)}$在长时间尺度上保持对底层动力学的敏感性。此外，在量子演化过程中插入Pauli算子，并在Heisenberg图像中随机化Pauli字符串的相位，我们观察到OTOC$^{(2)}$值发生了显著变化。这表明OTOC$^{(2)}$主要由形成配置空间大环的Pauli字符串之间的构造性干涉所主导。观察到的干涉机制赋予了OTOC$^{(2)}$高度的经典模拟复杂度，最终导致一组大规模的OTOC$^{(2)}$测量超过了已知经典算法的模拟能力。此外，通过OTOC$^{(2)}$进行哈密顿学习的一个示例进一步支持了我们的结果，表明了一条实现实用量子优势的可行路径。
                </div>
                <a href="https://arxiv.org/abs/2506.10191" class="link">https://arxiv.org/abs/2506.10191</a>
                <div class="comment-section">
                    <h3>评论</h3>
                    <input type="text" class="comment-input" id="comment-input-3" placeholder="输入评论">
                    <button class="comment-button" onclick="addComment(3)">提交评论</button>
                    <ul class="comment-list" id="comment-list-3"></ul>
                </div>
                </div>
                
                <div class="literature-item" style="background-color: #fff;">
                <h2>Synchronization for Fault-Tolerant Quantum Computers</h2>
                <div class="authors">Satvik Maurya, Swamit Tannu</div>
                <div class="summary">
                摘要：该文探讨了量子错误纠正（QEC）代码中逻辑量子比特同步的问题。表面码作为容错量子计算的领先方案，因其对物理错误的高度抗干扰能力而备受关注。然而，逻辑量子比特在综合征生成周期中的不同阶段可能导致系统去同步，这可能由非Clifford态的产生、制造缺陷引起的下降，以及与其他QEC代码结合使用以减少资源需求所致。逻辑操作需要参与的逻辑量子比特的综合征生成周期同步。这要求首位量子比特暂停或放慢其周期，以便在下一个周期前积累更多错误，增加无法纠正错误的风险。

为了同步逻辑量子比特的综合征生成周期，我们定义了三项政策：被动式、主动式和混合式。被动式是基础且最简单的策略，即首位逻辑量子比特在与其它逻辑量子比特同步之前保持空闲。另一方面，主动式旨在通过在多个代码周期前插入短暂的空闲期，使首位逻辑量子比特逐渐放慢。这一方法将逻辑错误率（LER）与被动式相比最多降低了2.4倍。混合策略进一步通过减少同步松弛并运行几轮额外的纠错代码，将LER最多再降低3.4倍。此外，所提出的同步政策带来的逻辑错误率下降，在电路级噪声模型下实现了最长解码延迟的2.2倍加速。 
                </div>
                <a href="https://arxiv.org/abs/2506.10258" class="link">https://arxiv.org/abs/2506.10258</a>
                <div class="comment-section">
                    <h3>评论</h3>
                    <input type="text" class="comment-input" id="comment-input-4" placeholder="输入评论">
                    <button class="comment-button" onclick="addComment(4)">提交评论</button>
                    <ul class="comment-list" id="comment-list-4"></ul>
                </div>
                </div>
                
                <div class="literature-item" style="background-color: #fff;">
                <h2>Sequential transmission at short times</h2>
                <div class="authors">Archishna Bhattacharyya</div>
                <div class="summary">
                摘要：我们展示了在一个由量子信道组成的n重组合（\Xi^n）_{n \in \mathbb{N}}中，在短时间内传输和保留信息是可能的，该模型被建模为一个离散的量子马尔可夫半群，足够长以在某个有限的n生成纠缠。通过交替执行噪声和量子错误校正来实现这一点。我们通过在顺序设置中对一次性量子容量的下限进行非平凡估计，以n的函数形式展示了这一点，尝试建模一个线性量子网络并评估其分发纠缠的能力。在引人入胜地，诸如此类网络的传输速率 Turns out to be 属性 Of the spectrum of the channels composed in sequence, 并且传输中可能的最大错误可以用噪声模型的函数来界定。作为一个应用，我们推导出无限维纯损失信道的确切误差边界，该信道被认为是阻止纠缠分发的网络中的主要噪声来源。我们通过分析振幅 damping 信道及其玻色子对应物来阐述我们的结果。
                </div>
                <a href="https://arxiv.org/abs/2506.10285" class="link">https://arxiv.org/abs/2506.10285</a>
                <div class="comment-section">
                    <h3>评论</h3>
                    <input type="text" class="comment-input" id="comment-input-5" placeholder="输入评论">
                    <button class="comment-button" onclick="addComment(5)">提交评论</button>
                    <ul class="comment-list" id="comment-list-5"></ul>
                </div>
                </div>
                
                <div class="literature-item" style="background-color: #fff;">
                <h2>QSEA: Quantum Self-supervised Learning with Entanglement Augmentation</h2>
                <div class="authors">Lingxiao Li, Xiaohui Ni, Jing Li, Sujuan Qin, Fei Gao</div>
                <div class="summary">
                摘要：作为一种无监督特征表示范式，自监督学习（SSL）利用数据的固有结构提取有意义的特征，而不依赖于人工标注。尽管SSL成功，但仍存在一些问题，如模型容量有限或表示能力不足。量子SSL成为一个有希望的替代方案，因为它可以利用量子状态来增强表达能力和学习效率。本文提出了一种具有纠缠增强的量子SSL方法（QSEA）。与现有的量子SSL不同，QSEA引入了基于纠缠的样本生成方案和由保真度驱动的量子损失函数。具体来说，QSEA通过将辅助qubit与原始状态纠缠并应用参数化单元ary变换来构建增强样本。损失函数使用量子保真度定义，量化量子表示之间的相似性，有效捕获样本关系。实验结果表明，QSEA在多个基准测试中比现有的量子自监督方法表现更好，并在去相关噪声环境中显示出更强的稳定性。此框架为量子学习系统奠定了理论和实践基础，并推动了SSL中量子机器学习的发
                </div>
                <a href="https://arxiv.org/abs/2506.10306" class="link">https://arxiv.org/abs/2506.10306</a>
                <div class="comment-section">
                    <h3>评论</h3>
                    <input type="text" class="comment-input" id="comment-input-6" placeholder="输入评论">
                    <button class="comment-button" onclick="addComment(6)">提交评论</button>
                    <ul class="comment-list" id="comment-list-6"></ul>
                </div>
                </div>
                
                <div class="literature-item" style="background-color: #fff;">
                <h2>Context-Aware Unit Testing for Quantum Subroutines</h2>
                <div class="authors">Mykhailo Klymenko, Thong Hoang, Samuel A. Wilkinson, Bahar Goldozian, Suyu Ma, Xiwei Xu, Qinghua Lu, Muhammad Usman, Liming Zhu</div>
                <div class="summary">
                摘要：软件测试是经典软件开发生命周期中的一个关键部分，随着量子软件逐渐发展为大规模生产并遵循行业标准，这一原则预计将保持不变。由于量子信息的非确定性、潜在Hilbert空间的高维度、复杂的硬件噪声以及量子系统固有的非局域性，开发和测试量子软件带来了独特的挑战。在这项工作中，我们将量子子程序建模为参数化的量子信道，并探索了使用概率断言结合量子态图谱或统计测试来创建实用单元测试的可行性。为了解决与量子系统单元测试相关的计算复杂度问题，我们建议在测试过程中加入上下文感知。通过将所提出的理论框架应用于一个简单的准备Greenberger-Horne-Zeilinger态的三量子比特量子子程序以及Shor算法实现中的子程序，展示了该框架在准确性、状态空间覆盖和效率之间的权衡。
                </div>
                <a href="https://arxiv.org/abs/2506.10348" class="link">https://arxiv.org/abs/2506.10348</a>
                <div class="comment-section">
                    <h3>评论</h3>
                    <input type="text" class="comment-input" id="comment-input-7" placeholder="输入评论">
                    <button class="comment-button" onclick="addComment(7)">提交评论</button>
                    <ul class="comment-list" id="comment-list-7"></ul>
                </div>
                </div>
                
                <div class="literature-item" style="background-color: #fff;">
                <h2>Ultrahigh threshold nonstabilizer nonlinear quantum error correcting code</h2>
                <div class="authors">Maga Grafe, Kaixuan Zhou, Zaman Tekin, Zhiyuan Lin, Sen Li, Fengquan Zhang, Valentin Ivannikov, Tim Byrnes</div>
                <div class="summary">
                摘要：我们引入了一种新型的量子错误校正码，称为自旋子码，其基于由总自旋定义的空间。该码是一种非稳定化码，也是一种非线性量子错误校正码，这意味着量子信息被编码在一族参数化的量子态中，而不是线性的超positions叠加。综合征测量是通过投影到具有不同总自旋的状态来执行的，并带有一种修正方法，将状态映射回最大总自旋空间。我们表明，该码能够渐近地保护对任何单比特Pauli错误（对于高斯分布态如自旋相干态）的免疫能力。我们直接在去极化信道下评估性能，考虑了不同情况，包括和不包括初始化和测量错误，以及双比特错误。我们估计码容量阈值为32-75%，而现象学阈值为9-75%。
                </div>
                <a href="https://arxiv.org/abs/2506.10445" class="link">https://arxiv.org/abs/2506.10445</a>
                <div class="comment-section">
                    <h3>评论</h3>
                    <input type="text" class="comment-input" id="comment-input-8" placeholder="输入评论">
                    <button class="comment-button" onclick="addComment(8)">提交评论</button>
                    <ul class="comment-list" id="comment-list-8"></ul>
                </div>
                </div>
                
                <div class="literature-item" style="background-color: #fff;">
                <h2>Time-domain field correlation measurements enable tomography of highly multimode quantum states of light</h2>
                <div class="authors">Emanuel Hubenschmid, Guido Burkard</div>
                <div class="summary">
                摘要：最近在超快光学领域的进展促进了对光线高度多模量子态动力力的调查，通过将电-光调制样本应用于电磁场的量子态来展示这一点。然而，由于现有的切面重建方法需要测量许多正交、可区分的模式，因此对于具有先验未知统计和动力学的光学量子态进行完整的图像重建仍然是具有挑战性的。在这里，我们提出了一种基于时间域正交度相关测量的切面方案，并在理论上证明了其能够重建高度多模高斯态。与八端同调检测相比，两个本地振荡器脉冲在时间上更短且独立地延迟与脉冲量子态。可区分模式结构是在后处理从相关测量数据通过正交化得到的。我们展示了可以重建的模式数量随着使用的时间延迟数增加而增加，并随着本地振荡器的时间范围扩大而减少。我们通过在同调检测之前添加非线性晶体，将我们的相关测量方案扩展并优化到电-光调制样本，可能在中红外至THz区实现亚周期分辨率。通过分析存在于测量数据中的（量子）相关性，我们展示了在检测期间量子态的热化导致相关测量要求的原因。热化在强压缩限制下尤其明显，我们为此开发了一种非扰动理论。此外，通过在理论上建立完整的测量统计并展示如何从联合统计中获得脉冲福克态的光谱信息，我们开辟了将我们的切面方案扩展到非高斯态的途径。
                </div>
                <a href="https://arxiv.org/abs/2506.10483" class="link">https://arxiv.org/abs/2506.10483</a>
                <div class="comment-section">
                    <h3>评论</h3>
                    <input type="text" class="comment-input" id="comment-input-9" placeholder="输入评论">
                    <button class="comment-button" onclick="addComment(9)">提交评论</button>
                    <ul class="comment-list" id="comment-list-9"></ul>
                </div>
                </div>
                
                <div class="literature-item" style="background-color: #fff;">
                <h2>Unitary Scrambling and Collapse: A Quantum Diffusion Framework for Generative Modeling</h2>
                <div class="authors">Yihua Li, Jiayi Chen, Tamanna S. Kumavat, Kyriakos Flouris</div>
                <div class="summary">
                摘要：量子计算以其指数速度提升的承诺，迅速崛起为推动人工智能发展的强大范式。我们提出了QSC-Diffusion，这是第一个基于量子的扩散框架，用于图像生成。我们的方法在正向过程中结合了经典高斯噪声和量子混沌，并在反向去噪声过程中使用带有测量诱导坍塌的参数化量子电路——从而实现了端到端采样，无需依赖经典神经架构或预处理模块。为了解决深度量子模型中的优化挑战，我们引入了一种混合损失函数，以平衡保真度和多样性，并配以分治训练策略来缓解条寡平原问题。remarkably，QSC-Diffusion在多个数据集上实现了具有竞争力的FID得分，同时使用的参数数量少了几个数量级，甚至在效率方面超越了一些量子-经典混合基线。这些结果凸显了量子本土生成建模的潜力，并标志着可扩展量子机器学习迈出的基本一步。
                </div>
                <a href="https://arxiv.org/abs/2506.10571" class="link">https://arxiv.org/abs/2506.10571</a>
                <div class="comment-section">
                    <h3>评论</h3>
                    <input type="text" class="comment-input" id="comment-input-10" placeholder="输入评论">
                    <button class="comment-button" onclick="addComment(10)">提交评论</button>
                    <ul class="comment-list" id="comment-list-10"></ul>
                </div>
                </div>
                
                <div class="literature-item" style="background-color: #fff;">
                <h2>Universal gates for a metastable qubit in strontium-88</h2>
                <div class="authors">Renhao Tao, Ohad Lib, Flavien Gyger, Hendrik Timme, Maximilian Ammenwerth, Immanuel Bloch, Johannes Zeiher</div>
                <div class="summary">
                摘要：亚稳态原子量子比特是一种非常有前途的实现量子计算机的平台，原因在于它们的可扩展性以及在电路中将泄漏错误转换为擦除错误的可能性。在这里，我们展示并表征了一个通用门集，用于编码在钡-88的$^3\text{P}_0$和$^3\text{P}_2$态之间的亚稳态微分结构量子比特。我们发现单量子比特门的保真度为0.993(1)，两量子比特门的保真度为0.9945(6)（在纠正门操作期间的损失后）。此外，我们提出了一种针对两个微分结构态的新型状态解析检测方案，能够实现高保真度的量子比特丢失检测。最后，我们利用qubit子空间之外的一个稳定基态，使用快速破坏性成像进行中路擦除转换。我们的结果确立了锶微分结构量子比特作为一种有前途的候选者，为近期具有错误纠正的量子计算机提供了独特的扩展视角。
                </div>
                <a href="https://arxiv.org/abs/2506.10714" class="link">https://arxiv.org/abs/2506.10714</a>
                <div class="comment-section">
                    <h3>评论</h3>
                    <input type="text" class="comment-input" id="comment-input-11" placeholder="输入评论">
                    <button class="comment-button" onclick="addComment(11)">提交评论</button>
                    <ul class="comment-list" id="comment-list-11"></ul>
                </div>
                </div>
                
                <div class="literature-item" style="background-color: #fff;">
                <h2>Certification of quantum networks using the generalised Choi isomorphism</h2>
                <div class="authors">Sophie Egelhaaf, Roope Uola</div>
                <div class="summary">
                摘要：我们提出了一种用于认证量子态和测量在直线网络中的纠缠性质的框架，该框架基于广义Choi同构，可以将二分态和测量映射到相应的量子操作。我们将该方法应用于具有可信终点的网络，以展示这种方法的强大功能。我们推导出关于单个源态的常见凸几何纠缠量器的边界，以及整个网络的边界。我们还将该技术应用于纠缠维度认证，并在此过程中提出了双部分测量的Schmidt数概念。我们认为这种量器可能会引起用于qutrit teleportation等领域中使用的探测器基准测试的兴趣。进一步将我们的形式应用于高维网络，我们推导出真实高维量子steering的激活结果。
                </div>
                <a href="https://arxiv.org/abs/2506.10725" class="link">https://arxiv.org/abs/2506.10725</a>
                <div class="comment-section">
                    <h3>评论</h3>
                    <input type="text" class="comment-input" id="comment-input-12" placeholder="输入评论">
                    <button class="comment-button" onclick="addComment(12)">提交评论</button>
                    <ul class="comment-list" id="comment-list-12"></ul>
                </div>
                </div>
                
                <div class="literature-item" style="background-color: #fff;">
                <h2>Constructing Quantum Many-Body Scars from Hilbert Space Fragmentation</h2>
                <div class="authors">Fan Yang, Matteo Magoni, Hannes Pichler</div>
                <div class="summary">
                摘要：这篇文章探讨了量子多体伤疤（QMBS），一种在遍历系统中表现出异常非热行为的特殊多体状态。通过动能受限的量子模型，研究者展示了如何构造简单、可扩展且直观的QMBS，该模型表现出弱希尔伯特空间碎片化。此外，文章指出，可以通过在晶格中注入拟粒子激发来构建精确的QMBS塔，并通过多个拟粒子的非弹性碰撞构建近似的伤疤。研究结果表明，量子多体伤疤与希尔伯特空间碎片化之间存在直接联系，为系统地构建精确和近似QMBS铺平了道路。该模型可轻松实现于强瑞利相互作用辅助的中性原子量子模拟器上
                </div>
                <a href="https://arxiv.org/abs/2506.10806" class="link">https://arxiv.org/abs/2506.10806</a>
                <div class="comment-section">
                    <h3>评论</h3>
                    <input type="text" class="comment-input" id="comment-input-13" placeholder="输入评论">
                    <button class="comment-button" onclick="addComment(13)">提交评论</button>
                    <ul class="comment-list" id="comment-list-13"></ul>
                </div>
                </div>
                
                <div class="literature-item" style="background-color: #fff;">
                <h2>Light Dark Matter Detection with Sub-eV Transition-Edge Sensors</h2>
                <div class="authors">Muping Chen, Volodymyr Takhistov, Kazunori Nakayama, Kaori Hattori</div>
                <div class="summary">
                
                </div>
                <a href="https://arxiv.org/abs/2506.10070" class="link">https://arxiv.org/abs/2506.10070</a>
                <div class="comment-section">
                    <h3>评论</h3>
                    <input type="text" class="comment-input" id="comment-input-14" placeholder="输入评论">
                    <button class="comment-button" onclick="addComment(14)">提交评论</button>
                    <ul class="comment-list" id="comment-list-14"></ul>
                </div>
                </div>
                
                <div class="literature-item" style="background-color: #fff;">
                <h2>Adaptive Job Scheduling in Quantum Clouds Using Reinforcement Learning</h2>
                <div class="authors">Waylon Luo (1), Jiapeng Zhao (2), Tong Zhan (3), Qiang Guan (1) ((1) Kent State University, (2) Cisco, (3) Meta)</div>
                <div class="summary">
                摘要：当今的量子系统面临关键瓶颈，包括有限的量子位数、短暂的相干区间和高的易错性，这些问题都阻碍了大规模和复杂电路的执行。量子算法的进步超过了现有量子硬件的能力，使得有效缩放计算变得困难。此外，硬件性能的不一致性和普遍存在的量子噪声削弱了系统的稳定性和计算精度。在这些约束条件下，为了优化量子工作负载，对任务调度和资源协调采取战略性的方法至关重要。这些方法必须旨在加速处理、保持操作保真度并减少分布式设置固有的通信负担。在该领域中，一个持续的挑战是如何有效地将大型电路分解并跨多个量子处理单元（QPUs）执行，特别是在易出错的环境中。为了应对这一挑战，我们引入了一种基于模拟的工具，该工具支持通过实时经典信道连接的网络QPUs上分布式调度和并发执行量子作业。该工具对超出单个QPU限制的工作负载建模电路分解，使得可以通过互处理器通信实现并行执行。在这个模拟环境中，我们比较了四种不同的调度技术，其中包括一种由强化学习信息的模型。这些策略根据运行时效率、保真度保留和通信成本等多个指标进行评估。我们的分析突出了每种方法固有的权衡，并强调了如何通过并行化、噪声感知的调度可以显著提高分布式量子基础设施中的计算吞吐量
                </div>
                <a href="https://arxiv.org/abs/2506.10889" class="link">https://arxiv.org/abs/2506.10889</a>
                <div class="comment-section">
                    <h3>评论</h3>
                    <input type="text" class="comment-input" id="comment-input-15" placeholder="输入评论">
                    <button class="comment-button" onclick="addComment(15)">提交评论</button>
                    <ul class="comment-list" id="comment-list-15"></ul>
                </div>
                </div>
                
                <div class="literature-item" style="background-color: #fff;">
                <h2>How much entanglement is needed for quantum error correction?</h2>
                <div class="authors">Sergey Bravyi, Dongjin Lee, Zhi Li, Beni Yoshida</div>
                <div class="summary">
                摘要：人们通常认为，能够纠正更多错误的量子纠错码的逻辑态必须具有高度的纠缠性。然而，我们在这里展示了这一信念的正确性取决于具体的码以及所选择的纠缠度量。在此目的上，我们表征了一个代码距离d与逻辑态几何纠缠度量之间的权衡，d量化了可纠正错误的数量，而几何纠缠度则量化了逻辑态与乘积态或更一般意义上的“拓扑平凡”态的最大重叠。我们证明，对于三类码：（1）具有互相通行检查操作符的低密度奇偶校验码，（2）稳定子码，以及（3）具有恒定编码率的码，其最大重叠在d的情况下是呈指数级小的。换句话说，这些码的任何逻辑态的几何纠缠至少随着d线性增长。另一方面，我们还展示了这种距离-纠缠权衡并不普遍成立。对于任意常数d和k（逻辑qubit的数量），我们证明存在这样一类码：在代码长度趋大极限时，某些逻辑态的几何纠缠接近于零。
                </div>
                <a href="https://arxiv.org/abs/2405.01332" class="link">https://arxiv.org/abs/2405.01332</a>
                <div class="comment-section">
                    <h3>评论</h3>
                    <input type="text" class="comment-input" id="comment-input-16" placeholder="输入评论">
                    <button class="comment-button" onclick="addComment(16)">提交评论</button>
                    <ul class="comment-list" id="comment-list-16"></ul>
                </div>
                </div>
                
                <div class="literature-item" style="background-color: #fff;">
                <h2>Quantum random access memory with transmon-controlled phonon routing</h2>
                <div class="authors">Zhaoyou Wang, Hong Qiao, Andrew N. Cleland, Liang Jiang</div>
                <div class="summary">
                摘要：量子随机存取存储器（QRAM）有望实现多个存储位置的同时数据查询，并以连贯的叠加态检索数据，这对于在许多量子算法中实现量子加速至关重要。我们引入了特易蒙控制的声子路由器，并提出了通过将这些路由器连接成树状架构来实施QRAM的方法。该路由器根据控制特易蒙的状态控制移动表面声波子的运动，从而实现了QRAM的核心功能，即条件式路由。我们的QRAM设计紧凑、支持快速路由操作，并避免频率拥挤。此外，我们提出了基于混合双轨道编码的方法，以检测主导损失错误，而无需额外硬件，这是一种可应用于其他QRAM平台的通用方法。我们的估算表明，使用当前设备参数，所提出的QRAM平台可以实现高速信号传达，其保形度主要受限于特易蒙的去相
                </div>
                <a href="https://arxiv.org/abs/2411.00719" class="link">https://arxiv.org/abs/2411.00719</a>
                <div class="comment-section">
                    <h3>评论</h3>
                    <input type="text" class="comment-input" id="comment-input-17" placeholder="输入评论">
                    <button class="comment-button" onclick="addComment(17)">提交评论</button>
                    <ul class="comment-list" id="comment-list-17"></ul>
                </div>
                </div>
                
                <div class="literature-item" style="background-color: #fff;">
                <h2>Efficient Excited-State Calculations for Molecules Based on Contextual Subspace Method and Symmetry Optimizations</h2>
                <div class="authors">Qianjun Yao, He Li</div>
                <div class="summary">
                摘要：虽然激发态计算的量子计算方法在Noisy Intermediate-Scale Quantum（NISQ）硬件上仍然未得到充分探索，但它们在光化学和材料科学中起着至关重要的作用。我们提出了一种资源高效的框架，该框架将上下文子空间（CS）方法与变分量子压缩（VQD）算法相结合，使得分子激发态的系统性计算能够在减少量子比特需求的情况下实现。基于数值结果，我们发现这种组合在用于计算激发态以减少qubit方面是可行的。此外，我们展示了使用旋转对称的硬件高效分解（HEA），即$\mathcal{N}(\theta_x,\theta_y,\theta_z)$块分解，使得在投影子空间内能够利用自旋对称性，从而进一步降低了计算资源需求。与通常使用的$R_{y}R_{z}$分解相比，使用$\mathcal{N}(\theta_x,\theta_y,\theta_z)$分解可以将优化迭代次数最多减少3倍，同时保持类似的电路深度
                </div>
                <a href="https://arxiv.org/abs/2502.17932" class="link">https://arxiv.org/abs/2502.17932</a>
                <div class="comment-section">
                    <h3>评论</h3>
                    <input type="text" class="comment-input" id="comment-input-18" placeholder="输入评论">
                    <button class="comment-button" onclick="addComment(18)">提交评论</button>
                    <ul class="comment-list" id="comment-list-18"></ul>
                </div>
                </div>
                
                <div class="literature-item" style="background-color: #fff;">
                <h2>Digital quantum simulation of squeezed states via enhanced bosonic encoding in a superconducting quantum processor</h2>
                <div class="authors">Hengyue Li, Yusheng Yang, Zhe-Hui Wang, Shuxin Xie, Zilong Zha, Hantao Sun, Jie Chen, Jian Sun, Shenggang Ying</div>
                <div class="summary">
                摘要：我们提出了一种全数字方法，用于在超导量子处理器上模拟单模式压缩态，采用增强的玻色子编码策略。通过将最多2^n个光子福克态映射到n个量子比特上，我们的框架利用基于格雷码的编码来减少与传统的一热或二进制映射相比的门开销。我们进一步通过仅限制模拟偶数个光子的福克态来优化资源使用，有效地将可表示的光子数量范围提高了一倍。为了克服当前硬件中的噪声和有限的相干性，我们采用了变分式量子模拟协议，该协议通过迭代优化适应浅层参数化电路。在Zuchongzhi-2超导平台上实现后，我们的方法展示了从真空态准备（r=0）到超过福克空间截断极限（r>1.63）的压缩水平范围内的压缩态动力学。量子状态断幂和维格纳函数分析证实了高保真度的状态准备，并展示了受Gray码启发的技术在实现基于量子比特的近期设备上进行连续变量物理的潜力。
                </div>
                <a href="https://arxiv.org/abs/2505.10895" class="link">https://arxiv.org/abs/2505.10895</a>
                <div class="comment-section">
                    <h3>评论</h3>
                    <input type="text" class="comment-input" id="comment-input-19" placeholder="输入评论">
                    <button class="comment-button" onclick="addComment(19)">提交评论</button>
                    <ul class="comment-list" id="comment-list-19"></ul>
                </div>
                </div>
                
                <div class="literature-item" style="background-color: #fff;">
                <h2>Active Quantum Reservoir Engineering: Using a Qubit to Manipulate its Environment</h2>
                <div class="authors">Marcelo Janovitch, Matteo Brunelli, Patrick P. Potts</div>
                <div class="summary">
                摘要：量子储层工程利用耗散过程来实现所需的行为，其应用范围从纠缠生成到量子错误校正。其中，结构化环境充当系统的熵沉池，无需对系统进行时间依赖性控制。我们开发了一种主动储层工程框架，其中通过对量子系统的时间依赖性控制来操纵其环境。在这种情况下，系统可能作为环境的熵沉池。我们的框架捕捉了系统与环境之间的动态相互作用，并提供了一种直观的图像，说明如何通过有限尺寸效应和系统-环境关联以及反复初始化量子系统来操纵环境。我们用两个例子来说明我们的结果：一个是耦合到双级系统环境的超导量子比特，以及耦合到核自旋的半导体量子点。在这两种情况下，我们发现与先前实验结果的一致性，表明主动控制如何在开放量子系统中解锁新的功能。
                </div>
                <a href="https://arxiv.org/abs/2505.16898" class="link">https://arxiv.org/abs/2505.16898</a>
                <div class="comment-section">
                    <h3>评论</h3>
                    <input type="text" class="comment-input" id="comment-input-20" placeholder="输入评论">
                    <button class="comment-button" onclick="addComment(20)">提交评论</button>
                    <ul class="comment-list" id="comment-list-20"></ul>
                </div>
                </div>
                
                <div class="literature-item" style="background-color: #fff;">
                <h2>Giant Atom with Disorders</h2>
                <div class="authors">Muming Han, Lingzhen Guo</div>
                <div class="summary">
                摘要：研究巨原子超越了传统量子光学中局部相互作用范式，并预测了一些新现象，例如在连续谱中的振荡束缚态（BICs）和无退相干相互作用（DFI），这些现象在小原子中是不存在的，这些现象是在某些特定的耦合位置和强度参数设置下才出现的。然而，在实际实验中实现巨原子系统时，耦合位置和强度总会有一定程度的无序性。本工作研究了无序性对与巨原子相关现象的影响。我们发现，与巨原子相关的现象在马尔可夫体制下对耦合位置和强度的无序性具有很好的鲁棒性，但是在非马尔可夫体制下对耦合位置的无序性更敏感。我们的工作表明，要观察到巨原子系统中的非马尔可夫现象（如振荡BICs），实验中需要比控制耦合强度的无序性更加精确地控制耦合位置的无序性。
                </div>
                <a href="https://arxiv.org/abs/2506.03628" class="link">https://arxiv.org/abs/2506.03628</a>
                <div class="comment-section">
                    <h3>评论</h3>
                    <input type="text" class="comment-input" id="comment-input-21" placeholder="输入评论">
                    <button class="comment-button" onclick="addComment(21)">提交评论</button>
                    <ul class="comment-list" id="comment-list-21"></ul>
                </div>
                </div>
                
                <div class="literature-item" style="background-color: #fff;">
                <h2>Evolution of a twisted electron wave packet perturbed by an inhomogeneous electric field</h2>
                <div class="authors">A. Kudlis, I. A. Aleksandrov, N. N. Rosanov</div>
                <div class="summary">
                摘要：拉盖尔-高斯（LG）波包以其涡旋结构和非零轨道角动量（OAM）而闻名，在各个科学领域都具有极大的兴趣。这里我们研究了一个空间局域化的电子LG波包与破坏初始波函数轴对称性的非均匀外部电场之间的非相对论动力学。我们专注于分析电子密度，并展示它如何受到外部电场的影响。在扰动理论的第一阶中，我们计算了电子波函数并揭示了电场可能会显著改变波包的结构并扭曲其定性形式。我们证明，由于与外部电场的相互作用，初始波函数在$z$轴上的退化零点会分裂为横向平面上多个非退化节点，这些节点代表单独的带电涡旋。这一机制类似于拓扑光学中已知的类似效应。这些发现为控制和操作twisted matter beams以及研究其可能的不稳定性提供了新的见解。
                </div>
                <a href="https://arxiv.org/abs/2506.06548" class="link">https://arxiv.org/abs/2506.06548</a>
                <div class="comment-section">
                    <h3>评论</h3>
                    <input type="text" class="comment-input" id="comment-input-22" placeholder="输入评论">
                    <button class="comment-button" onclick="addComment(22)">提交评论</button>
                    <ul class="comment-list" id="comment-list-22"></ul>
                </div>
                </div>
                
                <div class="literature-item" style="background-color: #fff;">
                <h2>Majorana Signatures in the Tripartite Uncertainty Relations with Quantum Memory</h2>
                <div class="authors">D. Maroulakos, C. Jasiukiewicz, A. Wal, A. Sinner, I. Weymann, T. Domański, L. Chotorlishvili</div>
                <div class="summary">
                摘要：量子性质对测量精度施加了基本限制。典型的例子包括海森堡的不确定性关系、罗伯逊的公式以及改进后的不确定性关系。然而，更普遍的措施是用量子熵来表达。不确定性测量在一个量子系统上与另一个量子系统相关联，这是一个更有趣的问题。量子关联可以影响不确定性的下限，而原因就在于量子记忆。在本文中，我们研究了通过超导体连接的第二个量子点对第一个量子点进行测量的不确定性。我们证明Majorana准素粒子使得不确定性达到可能的最小下界。通过严格的理论考虑，我们从实验相关的结果中仅用两个参数表达：Majorana模式之间的重叠和它们与量子点的耦合强度。我们展示了Majorana模式之间的重叠减少了量子不确定性，这是一个具有基本重要性的通用结果。此外，我们提出了一个协议，以测量顺序地在两个量子点上测量自旋，并证明第二次测量的结果将取决于Majorana准素粒子的存在。这可以作为一种间接工具用于它们的实证观察，对于正在进行的关于在纳米杂化结构中无歧义检测Majorana准素粒子的讨论具有重要意义。
                </div>
                <a href="https://arxiv.org/abs/2506.09621" class="link">https://arxiv.org/abs/2506.09621</a>
                <div class="comment-section">
                    <h3>评论</h3>
                    <input type="text" class="comment-input" id="comment-input-23" placeholder="输入评论">
                    <button class="comment-button" onclick="addComment(23)">提交评论</button>
                    <ul class="comment-list" id="comment-list-23"></ul>
                </div>
                </div>
                
                <div class="literature-item" style="background-color: #fff;">
                <h2>High-fidelity single-spin shuttling in silicon</h2>
                <div class="authors">Maxim De Smet, Yuta Matsumoto, Anne-Marije J. Zwerver, Larysa Tryputen, Sander L. de Snoo, Sergey V. Amitonov, S.R. Katiraee-Far, Amir Sammak, Nodar Samkharadze, Önder Gül, Rick N. M. Wasserman, E. Greplová, Maximilian Rimbach-Russ, Giordano Scappucci, Lieven M.K. Vandersypen</div>
                <div class="summary">
                摘要：这段文字描述了在半导体自旋量子比特中研究电子的自旋一致移动和运输，探讨如何通过增加量子比特间的连接性来提升大型量子处理器的计算能力和容错性。这些内容与关键词中的“qubit”（量子比特）、“quantum error correction”（量子纠错码）等强相关，因为它们涉及构建大规模量子计算机所需的连接性和保真度。
                </div>
                <a href="https://arxiv.org/abs/2406.07267" class="link">https://arxiv.org/abs/2406.07267</a>
                <div class="comment-section">
                    <h3>评论</h3>
                    <input type="text" class="comment-input" id="comment-input-24" placeholder="输入评论">
                    <button class="comment-button" onclick="addComment(24)">提交评论</button>
                    <ul class="comment-list" id="comment-list-24"></ul>
                </div>
                </div>
                
        <script>
        function addComment(paperIndex) {
            const commentInput = document.getElementById(`comment-input-${paperIndex}`);
            const commentText = commentInput.value;
            if (commentText) {
                const commentList = document.getElementById(`comment-list-${paperIndex}`);
                const now = new Date();
                const timestamp = now.toLocaleString();
                const newComment = document.createElement('li');
                newComment.textContent = `${timestamp}: ${commentText}`;
                commentList.appendChild(newComment);
                // 保存评论到本地存储
                let comments = JSON.parse(localStorage.getItem(`comments-${paperIndex}`)) || [];
                comments.push(`${timestamp}: ${commentText}`);
                localStorage.setItem(`comments-${paperIndex}`, JSON.stringify(comments));
                commentInput.value = '';
            }
        }
        
        // 页面加载时显示本地存储的评论
        window.onload = function () {
            const comments0 = JSON.parse(localStorage.getItem(`comments-0`)) || []; const commentList0 = document.getElementById(`comment-list-0`); comments0.forEach(comment => { const newComment = document.createElement('li'); newComment.textContent = comment; commentList0.appendChild(newComment); });const comments1 = JSON.parse(localStorage.getItem(`comments-1`)) || []; const commentList1 = document.getElementById(`comment-list-1`); comments1.forEach(comment => { const newComment = document.createElement('li'); newComment.textContent = comment; commentList1.appendChild(newComment); });const comments2 = JSON.parse(localStorage.getItem(`comments-2`)) || []; const commentList2 = document.getElementById(`comment-list-2`); comments2.forEach(comment => { const newComment = document.createElement('li'); newComment.textContent = comment; commentList2.appendChild(newComment); });const comments3 = JSON.parse(localStorage.getItem(`comments-3`)) || []; const commentList3 = document.getElementById(`comment-list-3`); comments3.forEach(comment => { const newComment = document.createElement('li'); newComment.textContent = comment; commentList3.appendChild(newComment); });const comments4 = JSON.parse(localStorage.getItem(`comments-4`)) || []; const commentList4 = document.getElementById(`comment-list-4`); comments4.forEach(comment => { const newComment = document.createElement('li'); newComment.textContent = comment; commentList4.appendChild(newComment); });const comments5 = JSON.parse(localStorage.getItem(`comments-5`)) || []; const commentList5 = document.getElementById(`comment-list-5`); comments5.forEach(comment => { const newComment = document.createElement('li'); newComment.textContent = comment; commentList5.appendChild(newComment); });const comments6 = JSON.parse(localStorage.getItem(`comments-6`)) || []; const commentList6 = document.getElementById(`comment-list-6`); comments6.forEach(comment => { const newComment = document.createElement('li'); newComment.textContent = comment; commentList6.appendChild(newComment); });const comments7 = JSON.parse(localStorage.getItem(`comments-7`)) || []; const commentList7 = document.getElementById(`comment-list-7`); comments7.forEach(comment => { const newComment = document.createElement('li'); newComment.textContent = comment; commentList7.appendChild(newComment); });const comments8 = JSON.parse(localStorage.getItem(`comments-8`)) || []; const commentList8 = document.getElementById(`comment-list-8`); comments8.forEach(comment => { const newComment = document.createElement('li'); newComment.textContent = comment; commentList8.appendChild(newComment); });const comments9 = JSON.parse(localStorage.getItem(`comments-9`)) || []; const commentList9 = document.getElementById(`comment-list-9`); comments9.forEach(comment => { const newComment = document.createElement('li'); newComment.textContent = comment; commentList9.appendChild(newComment); });const comments10 = JSON.parse(localStorage.getItem(`comments-10`)) || []; const commentList10 = document.getElementById(`comment-list-10`); comments10.forEach(comment => { const newComment = document.createElement('li'); newComment.textContent = comment; commentList10.appendChild(newComment); });const comments11 = JSON.parse(localStorage.getItem(`comments-11`)) || []; const commentList11 = document.getElementById(`comment-list-11`); comments11.forEach(comment => { const newComment = document.createElement('li'); newComment.textContent = comment; commentList11.appendChild(newComment); });const comments12 = JSON.parse(localStorage.getItem(`comments-12`)) || []; const commentList12 = document.getElementById(`comment-list-12`); comments12.forEach(comment => { const newComment = document.createElement('li'); newComment.textContent = comment; commentList12.appendChild(newComment); });const comments13 = JSON.parse(localStorage.getItem(`comments-13`)) || []; const commentList13 = document.getElementById(`comment-list-13`); comments13.forEach(comment => { const newComment = document.createElement('li'); newComment.textContent = comment; commentList13.appendChild(newComment); });const comments14 = JSON.parse(localStorage.getItem(`comments-14`)) || []; const commentList14 = document.getElementById(`comment-list-14`); comments14.forEach(comment => { const newComment = document.createElement('li'); newComment.textContent = comment; commentList14.appendChild(newComment); });const comments15 = JSON.parse(localStorage.getItem(`comments-15`)) || []; const commentList15 = document.getElementById(`comment-list-15`); comments15.forEach(comment => { const newComment = document.createElement('li'); newComment.textContent = comment; commentList15.appendChild(newComment); });const comments16 = JSON.parse(localStorage.getItem(`comments-16`)) || []; const commentList16 = document.getElementById(`comment-list-16`); comments16.forEach(comment => { const newComment = document.createElement('li'); newComment.textContent = comment; commentList16.appendChild(newComment); });const comments17 = JSON.parse(localStorage.getItem(`comments-17`)) || []; const commentList17 = document.getElementById(`comment-list-17`); comments17.forEach(comment => { const newComment = document.createElement('li'); newComment.textContent = comment; commentList17.appendChild(newComment); });const comments18 = JSON.parse(localStorage.getItem(`comments-18`)) || []; const commentList18 = document.getElementById(`comment-list-18`); comments18.forEach(comment => { const newComment = document.createElement('li'); newComment.textContent = comment; commentList18.appendChild(newComment); });const comments19 = JSON.parse(localStorage.getItem(`comments-19`)) || []; const commentList19 = document.getElementById(`comment-list-19`); comments19.forEach(comment => { const newComment = document.createElement('li'); newComment.textContent = comment; commentList19.appendChild(newComment); });const comments20 = JSON.parse(localStorage.getItem(`comments-20`)) || []; const commentList20 = document.getElementById(`comment-list-20`); comments20.forEach(comment => { const newComment = document.createElement('li'); newComment.textContent = comment; commentList20.appendChild(newComment); });const comments21 = JSON.parse(localStorage.getItem(`comments-21`)) || []; const commentList21 = document.getElementById(`comment-list-21`); comments21.forEach(comment => { const newComment = document.createElement('li'); newComment.textContent = comment; commentList21.appendChild(newComment); });const comments22 = JSON.parse(localStorage.getItem(`comments-22`)) || []; const commentList22 = document.getElementById(`comment-list-22`); comments22.forEach(comment => { const newComment = document.createElement('li'); newComment.textContent = comment; commentList22.appendChild(newComment); });const comments23 = JSON.parse(localStorage.getItem(`comments-23`)) || []; const commentList23 = document.getElementById(`comment-list-23`); comments23.forEach(comment => { const newComment = document.createElement('li'); newComment.textContent = comment; commentList23.appendChild(newComment); });const comments24 = JSON.parse(localStorage.getItem(`comments-24`)) || []; const commentList24 = document.getElementById(`comment-list-24`); comments24.forEach(comment => { const newComment = document.createElement('li'); newComment.textContent = comment; commentList24.appendChild(newComment); });
        };
        </script>
        </body>
        </html>
        