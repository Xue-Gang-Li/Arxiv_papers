
        <!DOCTYPE html>
        <html lang="en">
        <head>
        <meta charset="UTF-8">
        <title>2025-09-17 Arxiv papers related with quantum computing overview</title>
        <style>
        
        body {
            font-family: Arial, sans-serif;
            line-height: 1.6;
            margin: 40px;
            background-color: #f5f5f5;
        }
        .literature-item {
            background-color: white;
            padding: 20px;
            margin-bottom: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }
        h2 {
            color: #333;
            font-size: 24px;
            margin-top: 0;
            padding-bottom: 10px;
            border-bottom: 3px solid #eee;
        }
        .authors {
            color: #666;
            font-style: italic;
            margin-bottom: 15px;
        }
        .summary {
            color: #444;
            text-align: justify;
        }
        .link {
            display: block;
            margin-top: 10px;
            font-size: 14px;
            color: #337ab7;
            text-decoration: none;
        }
        .comment-section {
            margin-top: 10px;
        }
        .comment-input {
            width: 80%;
            padding: 5px;
            margin-right: 5px;
        }
        .comment-button {
            padding: 5px 10px;
        }
        .comment-list {
            list-style-type: none;
            padding: 0;
            margin-top: 5px;
        }
        .comment-list li {
            border: 1px solid #eee;
            padding: 5px;
            margin-bottom: 3px;
        }
        
        </style>
        </head>
        <body>
        <h1>2025-09-17 Arxiv papers related with quantum computing overview</h1>
        
        <h1>Keywords: ['superconducting qubit', 'quantum error correction', 'superconducting circuit', 'surface code', 'transmon', 'quantum parity detection', 'quasiparticle', 'quantum sensor', 'charge parity']</h1>
        

                <div class="literature-item" style="background-color: #fff;">
                <h2>Privacy in continuous-variable distributed quantum sensing</h2>
                <div class="authors">A. de Oliveira Junior, Anton L. Andersen, Benjamin Lundgren Larsen, Sean William Moore, Damian Markham, Masahiro Takeoka, Jonatan Bohr Brask, Ulrik L. Andersen</div>
                <div class="summary">
                
                </div>
                <a href="https://arxiv.org/abs/2509.12338" class="link">https://arxiv.org/abs/2509.12338</a>
                <div class="comment-section">
                    <h3>评论</h3>
                    <input type="text" class="comment-input" id="comment-input-0" placeholder="输入评论">
                    <button class="comment-button" onclick="addComment(0)">提交评论</button>
                    <ul class="comment-list" id="comment-list-0"></ul>
                </div>
                </div>
                
                <div class="literature-item" style="background-color: #fff;">
                <h2>Enlarging the GKP stabilizer group for enhanced noise protection</h2>
                <div class="authors">Jonathan Pelletier, Baptiste Royer</div>
                <div class="summary">
                摘要：这项工作研究了通过重新定义GKP编码的稳定化子群来寻找在噪声条件下实现逻辑电路的最优方法。提出了一种算法，用于在GKP编码中找到给定逻辑Clifford电路的最佳实现，以减少损耗错误对计算的影响。数值模拟表明，该编译器可以延长运行Clifford电路时平方-GKP qubit的生命周期。
                </div>
                <a href="https://arxiv.org/abs/2509.12502" class="link">https://arxiv.org/abs/2509.12502</a>
                <div class="comment-section">
                    <h3>评论</h3>
                    <input type="text" class="comment-input" id="comment-input-1" placeholder="输入评论">
                    <button class="comment-button" onclick="addComment(1)">提交评论</button>
                    <ul class="comment-list" id="comment-list-1"></ul>
                </div>
                </div>
                
                <div class="literature-item" style="background-color: #fff;">
                <h2>Leveraging Machine Learning Force Fields (MLFFs) to Simulate Large Atomistic Systems for Fidelity Improvement of Superconducting Qubits and Sensors</h2>
                <div class="authors">Søren Smidstrup, Shela Aboud, Ricardo Borges, Anders Blom, Pankaj Aggarwal, Robert Freeman, Jamil Kawa</div>
                <div class="summary">
                摘要：材料工程使用原子级别的建模是开发量子比特和量子传感器的重要工具。然而，传统的密度泛函理论（DFT）并不能充分捕捉到涉及的全部物理现象，包括超导性、表面态等的关键方面和动力学。此外，在可模拟的系统尺寸方面也存在重大挑战，尤其是热性能在量子计算应用中的重要性。QuantumATK工具结合了基于LCAO基集的DFT和非平衡绿函数，以计算超导体与绝缘体界面以及拓扑绝缘体表面的特性。此外，该软件利用机器学习力场来模拟热性能，并在大规模系统中生成现实中的无定形几何。最后，将超导量子比特和传感器描述为双势阱势模型的两级系统，需要多体物理，本文展示了如何将电子-电子相互作用添加到基于原子尺度紧束缚模型的单粒子能级中，以描述现实中的双量子点系
                </div>
                <a href="https://arxiv.org/abs/2509.12509" class="link">https://arxiv.org/abs/2509.12509</a>
                <div class="comment-section">
                    <h3>评论</h3>
                    <input type="text" class="comment-input" id="comment-input-2" placeholder="输入评论">
                    <button class="comment-button" onclick="addComment(2)">提交评论</button>
                    <ul class="comment-list" id="comment-list-2"></ul>
                </div>
                </div>
                
                <div class="literature-item" style="background-color: #fff;">
                <h2>Stabilizer Perturbation Theory: A Systematic Construction via Schrieffer-Wolff Transformation</h2>
                <div class="authors">Xuzhe Ying, Kangle Li, Hoi Chun Po</div>
                <div class="summary">
                摘要：Perturbation theories provide valuable insights on quantum many-body systems. Systems of interacting particles, like electrons, are often treated perturbatively around exactly solvable Gaussian points. Systems of interacting qubits have gained increasing prominence as another class of models for quantum systems thanks to the recent advances in experimentally realizing mesoscopic quantum devices. Stabilizer states, innately defined on systems of qudits, have correspondingly emerged as another class of classically simulatable starting point for the study of quantum error-correcting codes and topological phases of matter in such devices. As a step towards analyzing more general quantum many-body problems on these platforms, we develop a systematic stabilizer perturbation theory in qubit systems. Our approach relies on the local Schrieffer-Wolff transformation, which we show can be efficiently performed through the binary encoding the Pauli algebra. As demonstrations, we first benchmark the stabilizer perturbation theory on the transverse field Ising chain in one dimension. The method is then further applied to \(\mathbb{Z}_2\) toric code on square lattice and kagome lattice to probe the tendency toward confinement for anyonic excitations.
                </div>
                <a href="https://arxiv.org/abs/2509.12621" class="link">https://arxiv.org/abs/2509.12621</a>
                <div class="comment-section">
                    <h3>评论</h3>
                    <input type="text" class="comment-input" id="comment-input-3" placeholder="输入评论">
                    <button class="comment-button" onclick="addComment(3)">提交评论</button>
                    <ul class="comment-list" id="comment-list-3"></ul>
                </div>
                </div>
                
                <div class="literature-item" style="background-color: #fff;">
                <h2>EmuPlat: A Framework-Agnostic Platform for Quantum Hardware Emulation with Validated Transpiler-to-Pulse Pipeline</h2>
                <div class="authors">Jun Ye, Jun Yong Khoo</div>
                <div class="summary">
                摘要：我们提出了一种框架无关的量子硬件仿真平台EmuPlat，该平台解决了高级量子编程框架与硬件特定脉冲控制系统之间的互操作性差距。与现有的在孤立软件栈中运行的解决方案不同，EmuPlat提供了一种统一的基础设施，使得CUDA-Q、Qiskit和Qibolab等多样化的量子计算生态系统能够无缝集成。该平台实施了一个完整的翻译器-编译器流水线，将抽象量子电路系统地转换为本机门级集合$\mathcal{G}_{\text{native}} = \{I, Z, RZ(\theta), \text{GPI2}(\phi), CZ, M\}$，包括四个阶段：(1)递归门分解，(2)实现虚拟Z优化的相位跟踪，(3)带有自动SWAP插入的连接性感知路由，以及(4)在尊重硬件定时约束的情况下进行确定性的脉冲编译。基于清晰架构原则和新颖适配器模式，我们设计了模块化架构，支持对多个量子动力学仿真引擎的可扩展集成，同时保持一致的接口。在超导Transmon架构上进行全面的基准测试：贝尔态准备实现了99.958%的保真度，而4-qubit Quantum Fourier Transform的实现成功展示了可扩展电路执行。通过使用TransformationValidator进行的端到端测试验证，EmuPlat成为加速混合量子-经典算法开发和硬件-软件协同设计的重要基础设施。
                </div>
                <a href="https://arxiv.org/abs/2509.12639" class="link">https://arxiv.org/abs/2509.12639</a>
                <div class="comment-section">
                    <h3>评论</h3>
                    <input type="text" class="comment-input" id="comment-input-4" placeholder="输入评论">
                    <button class="comment-button" onclick="addComment(4)">提交评论</button>
                    <ul class="comment-list" id="comment-list-4"></ul>
                </div>
                </div>
                
                <div class="literature-item" style="background-color: #fff;">
                <h2>Designing Shadow Tomography Protocols by Natural Language Processing</h2>
                <div class="authors">Yadong Wu, Pengfei Zhang, Ce Wang, Juan Yao, Yi-Zhuang You</div>
                <div class="summary">
                摘要：量子电路是量子科学中的基础框架，使得描述、分析和实现量子计算成为可能。然而，设计高效的电路，对于特定的计算任务而言仍然是一个主要挑战，这些电路通常由单量子比特门和两量子比特门构建而成。在这项工作中，我们引入了一种基于人工智能的新协议，用于量子电路设计，并使用阴影断层摄影技术进行基准测试，以实现高效的量子态读取。我们的方法从自然语言处理（NLP）技术中汲取灵感，首先通过优化两量子比特门的纠缠能力来选择一个紧凑的门词典。我们确定iSWAP门是一个关键元素，它显著增强了采样效率，从而得到一个最小的门集合{I, SWAP, iSWAP}。在此基础上，我们实现了一种通过强化学习训练的循环神经网络，用于生成高性能量子电路。经过训练的模型表现出强大的泛化能力，发现了超越训练集的低采样复杂度的高效电路架构。我们的NLP启发框架为量子计算提供了广阔的应用潜力，包括提取量子误差校正中逻辑量子比特的属性。
                </div>
                <a href="https://arxiv.org/abs/2509.12782" class="link">https://arxiv.org/abs/2509.12782</a>
                <div class="comment-section">
                    <h3>评论</h3>
                    <input type="text" class="comment-input" id="comment-input-5" placeholder="输入评论">
                    <button class="comment-button" onclick="addComment(5)">提交评论</button>
                    <ul class="comment-list" id="comment-list-5"></ul>
                </div>
                </div>
                
                <div class="literature-item" style="background-color: #fff;">
                <h2>Dynamics of Quantum Analogs of Classical Impact Oscillators</h2>
                <div class="authors">Arnab Acharya, Titir Mukherjee, Deepshikha Singh, Soumitro Banerjee</div>
                <div class="summary">
                摘要：这篇论文研究了量子类似经典冲击振荡器的动力学，以探索复杂的非线性行为在量子系统中如何表现。尽管经典冲击振荡器会出现混沌和分岔，而受线性方程支配的量子系统似乎不允许这种动力学，但通过对无强迫、有强迫和耗散量子振荡器的模拟，我们揭示了准周期性、奇异的非混沌态动力学，甚至在存在消ipation时的混沌。使用熵时间序列、傅里叶谱、OTOCs、Lyapunov分析和0-1测试等方法，我们证明量子系统可以表现出与经典非线性系统相类似的丰富的动力学特征，连接了量子力学和混沌理
                </div>
                <a href="https://arxiv.org/abs/2509.12835" class="link">https://arxiv.org/abs/2509.12835</a>
                <div class="comment-section">
                    <h3>评论</h3>
                    <input type="text" class="comment-input" id="comment-input-6" placeholder="输入评论">
                    <button class="comment-button" onclick="addComment(6)">提交评论</button>
                    <ul class="comment-list" id="comment-list-6"></ul>
                </div>
                </div>
                
                <div class="literature-item" style="background-color: #fff;">
                <h2>Data-Efficient Quantum Noise Modeling via Machine Learning</h2>
                <div class="authors">Yanjun Ji, Marco Roth, David A. Kreplin, Ilia Polian, Frank K. Wilhelm</div>
                <div class="summary">
                摘要：最大化近期量子处理器的计算效用需要有预测性的噪声模型，以指导强健的、噪声感知的编译和错误缓解。传统模型通常无法捕捉实际硬件的复杂错误动态，或者需要过高的特性化开销。我们引入了一种基于机器学习的数据高效框架，用于构建超导量子处理器的精确参数化噪声模型。我们的方法通过直接从现有应用和基准电路的测量数据中学习硬件特定错误参数，绕过了昂贵的特性化协议。该框架的一般性和鲁棒性通过对多个量子设备和算法的全面基准测试得到了证明。至关重要的是，我们展示了一种仅在小规模电路上训练的模型能够精确预测较大验证电路的行为。我们的数据高效方法相比从设备属性推导出的标准噪声模型，实现了最高可达65%的模型保真度提升，量化使用Hellinger距离测量预测和实验电路输出分布之间的差异。这项工作确立了一种实际的噪声特性化范例，为开发更有效的噪声感知编译和错误缓解策略提供了重要工
                </div>
                <a href="https://arxiv.org/abs/2509.12933" class="link">https://arxiv.org/abs/2509.12933</a>
                <div class="comment-section">
                    <h3>评论</h3>
                    <input type="text" class="comment-input" id="comment-input-7" placeholder="输入评论">
                    <button class="comment-button" onclick="addComment(7)">提交评论</button>
                    <ul class="comment-list" id="comment-list-7"></ul>
                </div>
                </div>
                
                <div class="literature-item" style="background-color: #fff;">
                <h2>First Practical Experiences Integrating Quantum Computers with HPC Resources: A Case Study With a 20-qubit Superconducting Quantum Computer</h2>
                <div class="authors">Eric Mansfield, Stefan Seegerer, Panu Vesanen, Jorge Echavarria, Burak Mete, Muhammad Nufail Farooqi, Laura Schulz</div>
                <div class="summary">
                摘要：将量子计算机整合到高性能计算（HPC）环境中（通常称为HPC+QC集成）是提高科学研究计算能力的关键一步。本文报道了超导20-quantum比特量子计算机与莱布尼茨超级计算中心（LRZ）的HPC基础设施整合，这是一项首批实际实现之一。我们获得了四个关键经验：(1) 量子计算机的设施要求比经典系统更严格，但在经过彻底场地调查以确保符合性之后，其部署在HPC环境中是可行的；(2) 量子计算机本质上是动态系统，需要定期重新校准，并且这种校准应由HPC调度器自动控制；(3) 冗余电源和冷却基础设施至关重要；(4) 应该为量子专家和新用户提供有效的实践培训。这些结论为未来的HPC中心整合提供了指南。
                </div>
                <a href="https://arxiv.org/abs/2509.12949" class="link">https://arxiv.org/abs/2509.12949</a>
                <div class="comment-section">
                    <h3>评论</h3>
                    <input type="text" class="comment-input" id="comment-input-8" placeholder="输入评论">
                    <button class="comment-button" onclick="addComment(8)">提交评论</button>
                    <ul class="comment-list" id="comment-list-8"></ul>
                </div>
                </div>
                
                <div class="literature-item" style="background-color: #fff;">
                <h2>Demonstration of a Logical Architecture Uniting Motion and In-Place Entanglement: Shor's Algorithm, Constant-Depth CNOT Ladder, and Many-Hypercube Code</h2>
                <div class="authors">Rich Rines, Benjamin Hall, Mariesa H. Teo, Joshua Viszlai, Daniel C. Cole, David Mason, Cameron Barker, Matt J. Bedalov, Matt Blakely, Tobias Bothwell, Caitlin Carnahan, Frederic T. Chong, Samuel Y. Eubanks, Brian Fields, Matthew Gillette, Palash Goiporia, Pranav Gokhale, Garrett T. Hickman, Marin Iliev, Eric B. Jones, Ryan A. Jones, Kevin W. Kuper, Stephanie Lee, Martin T. Lichtman, Kevin Loeffler, Nate Mackintosh, Farhad Majdeteimouri, Peter T. Mitchell, Thomas W. Noel, Ely Novakoski, Victory Omole, David Owusu-Antwi, Alexander G. Radnaev, Anthony Reiter, Mark Saffman, Bharath Thotakura, Teague Tomesh, Ilya Vinogradov</div>
                <div class="summary">
                摘要：逻辑量子比特被认为是实现实用规模量子计算的重要组成部分。最近在中性原子上多次展示了基于相干量子比特运动进入纠缠区的逻辑量子比特。然而，这种架构需要在每个纠缠门之前进行运动，导致大量墙钟运行时间成本和与运动相关的误差积累。我们提出了并实验实现了一种替代架构，该架构通过邻近邻居门将量子比特运动和就地纠缠结合在一起。我们的方法保持了所有到全部的连接性，同时最小化了量子比特运动开销。在Inflexion的Sqale QPU上，我们展示了三个关键结果，该QPU托管了114个中性原子量子比特阵列。首先，我们实现了Shor算法的一个预编译变体的逻辑量子比特化。我们发现，在包括损耗校正和泄漏检测在内的各种设置下，逻辑性能优于物理性能。其次，我们引入了一种执行CNOT梯度深度独立于逻辑量子比特数N和代码距离d的技术。在最初的8个和12个逻辑量子比特实验中，我们发现通过逻辑编码减少了约4倍的错误。第三，我们实验实现了[[16, 4, 4]] many-hypercube QEC代码的初始化。所有三个结果都受益于Superstaq的优化编译以及我们将运动和就地纠缠结合在一起的底层架构。这一架构为减少实用规模量子应用相对于基于纠缠区的架构的开销提供了一条路径。
                </div>
                <a href="https://arxiv.org/abs/2509.13247" class="link">https://arxiv.org/abs/2509.13247</a>
                <div class="comment-section">
                    <h3>评论</h3>
                    <input type="text" class="comment-input" id="comment-input-9" placeholder="输入评论">
                    <button class="comment-button" onclick="addComment(9)">提交评论</button>
                    <ul class="comment-list" id="comment-list-9"></ul>
                </div>
                </div>
                
                <div class="literature-item" style="background-color: #fff;">
                <h2>A Robust Modular Quantum Processor</h2>
                <div class="authors">Ramesh Bhandari</div>
                <div class="summary">
                摘要：我们探索了量子计算架构中关键元素的冗余概念，以规避由于此类元素故障（例如由灾难性宇宙射线事件引起）导致量子操作中断的问题。我们通过引用一个最近提出的具有星形配置的超导模块化量子架构来说明这一概念，其中中心有一个路由器，使得各个模块之间可以实现超导量子比特的相互作用。将这种路由器视为关键元素，我们提出了一种双星配置，其中如果其中一个路由器失效，第二个路由器可以提供备份。此外，我们还研究了在正常情况下（即量子硬件已通过其他减轻措施如屏蔽或移至地下设施而免受宇宙射线的影响）使用这种双星配置的实用性。在这种情况下，同时实现两对量子比特的相互作用（例如两个同时的CZ门）以及多量子比特门（如CCZS门）变得容易。
                </div>
                <a href="https://arxiv.org/abs/2509.13269" class="link">https://arxiv.org/abs/2509.13269</a>
                <div class="comment-section">
                    <h3>评论</h3>
                    <input type="text" class="comment-input" id="comment-input-10" placeholder="输入评论">
                    <button class="comment-button" onclick="addComment(10)">提交评论</button>
                    <ul class="comment-list" id="comment-list-10"></ul>
                </div>
                </div>
                
                <div class="literature-item" style="background-color: #fff;">
                <h2>Prediction of Stocks Index Price using Quantum GANs</h2>
                <div class="authors">Sangram Deshpande, Gopal Ramesh Dahale, Sai Nandan Morapakula, Uday Wad</div>
                <div class="summary">
                摘要：这篇论文研究了量子生成对抗网络（QGANs）在股票价格预测中的应用。金融市场本质上复杂，具有高波动性和传统模型通常无法捕捉的复杂模式。QGANs利用量子计算的力量，通过结合生成模型的优势和量子机器学习技术，提供了一种新的方法。我们实现了一个专为股票价格预测设计的QGAN模型，并使用历史股票市场数据评估其性能。我们的结果表明，QGANs可以生成类似于实际市场行为的合成数据，从而提高预测准确性。该实验使用Stocks指数价格数据进行，并使用AWS Braket SV1模拟器训练QGAN电路。量子增强模型在收敛速度和预测准确性方面优于经典长短期记忆网络（LSTM）和GAN模型。这项研究是将量子计算集成到金融预测中的一个关键步骤，提供了在速度和精度方面超越传统方法的潜在优势。这些发现对交易员、金融分析师和研究人员寻找高级市场分析工具具有重要意义。
                </div>
                <a href="https://arxiv.org/abs/2509.12286" class="link">https://arxiv.org/abs/2509.12286</a>
                <div class="comment-section">
                    <h3>评论</h3>
                    <input type="text" class="comment-input" id="comment-input-11" placeholder="输入评论">
                    <button class="comment-button" onclick="addComment(11)">提交评论</button>
                    <ul class="comment-list" id="comment-list-11"></ul>
                </div>
                </div>
                
                <div class="literature-item" style="background-color: #fff;">
                <h2>Higher-Form Anomalies on Lattices</h2>
                <div class="authors">Yitao Feng, Ryohei Kobayashi, Yu-An Chen, Shinsei Ryu</div>
                <div class="summary">
                
                </div>
                <a href="https://arxiv.org/abs/2509.12304" class="link">https://arxiv.org/abs/2509.12304</a>
                <div class="comment-section">
                    <h3>评论</h3>
                    <input type="text" class="comment-input" id="comment-input-12" placeholder="输入评论">
                    <button class="comment-button" onclick="addComment(12)">提交评论</button>
                    <ul class="comment-list" id="comment-list-12"></ul>
                </div>
                </div>
                
                <div class="literature-item" style="background-color: #fff;">
                <h2>Neural-Quantum-States Impurity Solver for Quantum Embedding Problems</h2>
                <div class="authors">Yinzhanghao Zhou, Tsung-Han Lee, Ao Chen, Nicola Lanatà, Hong Guo</div>
                <div class="summary">
                摘要：神经量子态（NQS）已成为一种有前途的解决第二量化哈密顿量方法，因为它们具有可扩展性和灵活性。在这项工作中，我们设计并测试了一个基于NQS的缺陷解算器，用于量子嵌入方法，重点关注鬼影古茨威勒近似（gGA）框架。我们引入了一种基于图变压器的NQS框架，能够表示任意连接的缺陷轨道，并开发了一种错误控制机制，以稳定量子嵌入循环中的迭代更新。我们通过对Anderson晶格模型的基准gGA计算验证了我们的方法的精度，该结果与精确对角化缺陷解算器的结果非常一致。最后，我们对计算预算的分析表明，该方法的主要瓶颈是嵌入循环所需的高精度物理观测采样，而不是NQS变分优化，直接突出了需要更高效的推断技术的重要性。
                </div>
                <a href="https://arxiv.org/abs/2509.12431" class="link">https://arxiv.org/abs/2509.12431</a>
                <div class="comment-section">
                    <h3>评论</h3>
                    <input type="text" class="comment-input" id="comment-input-13" placeholder="输入评论">
                    <button class="comment-button" onclick="addComment(13)">提交评论</button>
                    <ul class="comment-list" id="comment-list-13"></ul>
                </div>
                </div>
                
                <div class="literature-item" style="background-color: #fff;">
                <h2>Tracially embeddable strategies: Lifting MIP* tricks to MIPco</h2>
                <div class="authors">Junqiao Lin</div>
                <div class="summary">
                摘要：我们证明，在交换算子模型中，任何双方的关联都可以用可追踪嵌入策略来近似，这是一类定义在有限冯·诺伊曼代数上的策略。利用这一特性，我们展示了任何近似同步的关联都可以近似为交换算子模型中一批同步关联的平均值。这将Vidick [JMP 2022] 的结果推广到仅适用于有限维量子关联的情况。作为一个推论，我们展示了Ji等人在[FOCS 2022] 中提出的量子张量码测试在一般交换算子模型下仍然具有健全性属性。此外，我们将Gowers-Hatami定理的状态依赖范数版本扩展到有限冯·诺伊曼代数。结合上述特征，这使我们能够将关于非局域游戏强健自测试的许多已知结果提升到交换算子模型，包括对交换算子策略的有限维EPR测试样本效率。我们相信，除了本文的贡献之外，这类策略对于进一步理解无限维设置中的非局域游戏可能有所帮助。
                </div>
                <a href="https://arxiv.org/abs/2304.01940" class="link">https://arxiv.org/abs/2304.01940</a>
                <div class="comment-section">
                    <h3>评论</h3>
                    <input type="text" class="comment-input" id="comment-input-14" placeholder="输入评论">
                    <button class="comment-button" onclick="addComment(14)">提交评论</button>
                    <ul class="comment-list" id="comment-list-14"></ul>
                </div>
                </div>
                
                <div class="literature-item" style="background-color: #fff;">
                <h2>Tailoring Fault-Tolerance to Quantum Algorithms</h2>
                <div class="authors">Zhuangzhuang Chen, Narayanan Rengaswamy</div>
                <div class="summary">
                摘要：通用容错量子计算的一种标准方法是开发一种可以实现通用逻辑门集的容错机制，从而能够容错地运行任何量子算法。然而，已知只有特定量子算法才能从量子计算机中获得显著优势，因此使用定制的纠错方案编译这些特定算法可能对通用量子计算机有利。本研究致力于专为特定算法设计的容错方案。我们考虑了用于量子模拟的Trotter电路，并开发了一种系统综合物理实现Clifford Trotter电路到著名的错误检测码$\llbr n,n-2,2 \rrbr$的解析与缝合算法。分析表明，该方法在合理假设下以几乎最优深度实现Trotter电路，展示了定制量子纠错的潜力。通过标志装置实现容错，开销最小。此外，该算法可推广至更复杂的情况，如四比特逻辑Clifford Trotter电路在超图积码$\llbr 20,4,2 \rrbr$上的实现，为量子计算中的定制容错提供了系统方法。
                </div>
                <a href="https://arxiv.org/abs/2404.11953" class="link">https://arxiv.org/abs/2404.11953</a>
                <div class="comment-section">
                    <h3>评论</h3>
                    <input type="text" class="comment-input" id="comment-input-15" placeholder="输入评论">
                    <button class="comment-button" onclick="addComment(15)">提交评论</button>
                    <ul class="comment-list" id="comment-list-15"></ul>
                </div>
                </div>
                
                <div class="literature-item" style="background-color: #fff;">
                <h2>Dynamically Optimized Super-Robust Nonadiabatic Holonomic Quantum Gates Based on Superconducting Circuits</h2>
                <div class="authors">Hai Xu, Wanchun Li, Tao Chen, Kejin Wei, Chengxian Zhang</div>
                <div class="summary">
                摘要：非绝热全息量子计算（Nonadiabatic holonomic quantum computation, NHQC）利用非阿贝尔几何相位在非绝热框架中实现快速且鲁棒的量子门操作。然而，NHQC的实际实现面临实验环境中固有的控制不完美性挑战。确保对控制误差的深度抑制至关重要。在本工作中，我们提出了动态优化的NHQC方案，以构建通用超稳健全息量子门。所提出方案通过策略性地设计一组动态校正脉冲来实现循环演化，同时确保不需要和破坏性的动力学相位元素（包括以前被忽视的耦合项）积累。这种构建的超稳健NHQC方案高效保障了循环演化过程，并通过有效纠正四阶误差使全息门免受控制误差的影响。此外，当与超导量子电路中的去相干自由子空间（decoherence-free subspace, DFS）编码集成时，我们的方案可以实现高保真度的全息门，并展示了对控制误差和集体去相位错误的强大鲁棒性。因此，我们的工作为实现可扩展且容错的全息量子计算提供了一条有前景的路径。
                </div>
                <a href="https://arxiv.org/abs/2409.15665" class="link">https://arxiv.org/abs/2409.15665</a>
                <div class="comment-section">
                    <h3>评论</h3>
                    <input type="text" class="comment-input" id="comment-input-16" placeholder="输入评论">
                    <button class="comment-button" onclick="addComment(16)">提交评论</button>
                    <ul class="comment-list" id="comment-list-16"></ul>
                </div>
                </div>
                
                <div class="literature-item" style="background-color: #fff;">
                <h2>Gibbs state preparation for commuting Hamiltonian: Mapping to classical Gibbs sampling</h2>
                <div class="authors">Yeongwoo Hwang, Jiaqing Jiang</div>
                <div class="summary">
                摘要：这段文字主要讨论了Gibbs态准备或称为Gibbs采样的应用、交换局部哈密顿量的快速混合Gibbs采样器的设计，以及将其还原为经典哈密顿量的新方法。研究展示了该采样器在低温等先前未知领域的有效性，并提供了多个具体的还原案例。
                </div>
                <a href="https://arxiv.org/abs/2410.04909" class="link">https://arxiv.org/abs/2410.04909</a>
                <div class="comment-section">
                    <h3>评论</h3>
                    <input type="text" class="comment-input" id="comment-input-17" placeholder="输入评论">
                    <button class="comment-button" onclick="addComment(17)">提交评论</button>
                    <ul class="comment-list" id="comment-list-17"></ul>
                </div>
                </div>
                
                <div class="literature-item" style="background-color: #fff;">
                <h2>Volume-law entanglement fragmentation of quasiparticles</h2>
                <div class="authors">Jiaju Zhang</div>
                <div class="summary">
                摘要：我们研究了量子态中的纠缠熵，这些状态具有在动量空间中单位模式的重复序列激发。在缩放极限下，每个单位模式独立且普遍地为纠缠熵做出贡献，导致特征性的体积定律缩放。至关重要的是，这种普遍贡献对于自由和相互作用模型是相同的，使得总纠缠可以分解为基于模式的组件。在费米子和玻色链中进行数值验证确认了这种体积定律碎片化现象。对于费米子系统，我们推导出解析表达式，其中多体纠缠可以通过少体纠缠组件来表示。值得注意的是，通过适当的识别，这个分析框架扩展到了自旋-1/2 XXZ链。
                </div>
                <a href="https://arxiv.org/abs/2411.12379" class="link">https://arxiv.org/abs/2411.12379</a>
                <div class="comment-section">
                    <h3>评论</h3>
                    <input type="text" class="comment-input" id="comment-input-18" placeholder="输入评论">
                    <button class="comment-button" onclick="addComment(18)">提交评论</button>
                    <ul class="comment-list" id="comment-list-18"></ul>
                </div>
                </div>
                
                <div class="literature-item" style="background-color: #fff;">
                <h2>Measurement-free code-switching for low overhead quantum computation using permutation invariant codes</h2>
                <div class="authors">Yingkai Ouyang, Yumang Jing, Gavin K. Brennen</div>
                <div class="summary">
                摘要：横向量子门在量子误差纠正码中是一个有前途的容错量子计算方法，但受到Eastin-Knill不行定理的限制。现有的解决方案，如门传送和魔态蒸馏，资源消耗较大。我们提出了一种无需测量的代码切换协议，用于普遍的量子计算，将稳定子码与用于横向非Clifford门的置换不变性（PI）码进行切换，这些非Clifford门是任何有理数倍π的逻辑Z旋转。这种代码切换协议启用的新型非Clifford门提供了相对于Clifford+T门集更低的门次数实现普遍量子门集的方法。为此，我们提出了一种使用近期量子控制操作（利用催化波色子模式）在代码之间执行控制-NOT门的协议。此外，我们还提出了一种新的PI码，具有可调节的码距，支持横向非Clifford门，并证明了与相比稳定器码到稳定器码切换方案相比，其门数开销减少。
                </div>
                <a href="https://arxiv.org/abs/2411.13142" class="link">https://arxiv.org/abs/2411.13142</a>
                <div class="comment-section">
                    <h3>评论</h3>
                    <input type="text" class="comment-input" id="comment-input-19" placeholder="输入评论">
                    <button class="comment-button" onclick="addComment(19)">提交评论</button>
                    <ul class="comment-list" id="comment-list-19"></ul>
                </div>
                </div>
                
                <div class="literature-item" style="background-color: #fff;">
                <h2>Work Statistics via Real-Time Effective Field Theory: Application to Work Extraction from Thermal Bath with Qubit Coupling</h2>
                <div class="authors">Jhh-Jing Hong, Feng-Li Lin</div>
                <div class="summary">
                摘要：热量子态被认为是消极的，正如热力学第二定律所要求的。这篇文章研究了通过将热浴与自旋、费米子或拓扑型量子比特耦合来提取功的可能性，这些量子比特在不同温度下表现出不同的热量子态。提取的功是从非平衡循环过程中的功统计得出的。尽管许多体系统的功统计计算具有挑战性，但我们提出了一种有效场论方法，通过假设外部驱动源耦合到热量子态的特定准粒子算符来解决这个问题。我们展示了功统计可以简洁地表示为该准粒子的热谱函数。对于不带量子比特耦合的纯热浴，我们得到了非PERTurvative的功分布函数（WDF）。在带有量子比特耦合的情况下，我们得到第二阶的WDF，从而可以精确确定提取功的物理范围，以帮助设计量子热引擎或制冷器。它们的效率或性能系数（COP）可以从波动定理和第一定律的结合中推断出来，我们发现自旋/拓扑型量子比特-浴系统通常比其他两种替代方案产生更好的热引擎/制冷器，这是由于其潜在的量子统计。
                </div>
                <a href="https://arxiv.org/abs/2502.18812" class="link">https://arxiv.org/abs/2502.18812</a>
                <div class="comment-section">
                    <h3>评论</h3>
                    <input type="text" class="comment-input" id="comment-input-20" placeholder="输入评论">
                    <button class="comment-button" onclick="addComment(20)">提交评论</button>
                    <ul class="comment-list" id="comment-list-20"></ul>
                </div>
                </div>
                
                <div class="literature-item" style="background-color: #fff;">
                <h2>High-performance local decoders for defect matching in 1D</h2>
                <div class="authors">Louis Paletta, Anthony Leverrier, Mazyar Mirrahimi, Christophe Vuillot</div>
                <div class="summary">
                摘要：本地解码器，也称为细胞自动机解码器，为实现实时量子错误纠正提供了一条有希望的路径。通过用一种从简单的局部转换规则出发的天然并行和精简架构，取代了具有固有硬件约束的集中式经典解码。本文提出了两种针对一维量子重复码的新型本地解码器。信号规则解码器将相邻量子比特之间的奇偶性不匹配视为缺陷，通过交换经典点状激发（由几位局部存储器表示）使这些缺陷彼此吸引。我们证明了代码容量模型中存在阈值，并在现象学噪声模型下提供了数值证据表明逻辑错误被指数级抑制，考虑到每个纠错周期中的数据和测量误差。与先前已知的本地解码器相比，我们的构造大大缩小了阈值和尺度上的差距，使其在实际系统规模和错误率下更接近全局解码器。通过消除对局部经典存储器的需求，可以进一步减少实现要求，新定义了一种适用于两排量子比特的剪切规则。在相关系统规模下，该剪切规则效果良好，使其成为一种有吸引力的短期解决方案。当与偏噪声量子比特（如猫态量子比特）结合时，这些解码器能够在一维中实现完全本地化的量子存储。
                </div>
                <a href="https://arxiv.org/abs/2505.10162" class="link">https://arxiv.org/abs/2505.10162</a>
                <div class="comment-section">
                    <h3>评论</h3>
                    <input type="text" class="comment-input" id="comment-input-21" placeholder="输入评论">
                    <button class="comment-button" onclick="addComment(21)">提交评论</button>
                    <ul class="comment-list" id="comment-list-21"></ul>
                </div>
                </div>
                
                <div class="literature-item" style="background-color: #fff;">
                <h2>Nitrogen-vacancy centre in lonsdaleite: a novel nanoscale sensor?</h2>
                <div class="authors">Anjay Manian, Mitchell O. de Vries, Daniel Stavrevski, Qiang Sun, Salvy P. Russo, Andrew D. Greentree</div>
                <div class="summary">
                
                </div>
                <a href="https://arxiv.org/abs/2505.11240" class="link">https://arxiv.org/abs/2505.11240</a>
                <div class="comment-section">
                    <h3>评论</h3>
                    <input type="text" class="comment-input" id="comment-input-22" placeholder="输入评论">
                    <button class="comment-button" onclick="addComment(22)">提交评论</button>
                    <ul class="comment-list" id="comment-list-22"></ul>
                </div>
                </div>
                
                <div class="literature-item" style="background-color: #fff;">
                <h2>Is Circuit Depth Accurate for Comparing Quantum Circuit Runtimes?</h2>
                <div class="authors">Matthew Tremba, Paul Hovland, Ji Liu</div>
                <div class="summary">
                摘要：虽然量子电路深度通常用于估算运行时间，但它忽略了当前硬件实现的一个主要特性：不同门有不同的执行时间。认识到这一差异的可能性，我们研究了深度在比较同一电路编译版本的运行时间方面的准确性。特别是，我们评估了传统和多量子比特深度在(1)预测相对运行时间差异和(2)识别运行时间最短的编译电路版本方面的准确性。发现电路深度在这两项任务中都不够准确，因此我们引入了一种新的指标，即基于门的深度，它使用架构的平均门执行时间加权门对运行时间的贡献。使用平均门执行时间使基于门的深度能够在不需要了解所有门执行时间的情况下捕捉根据门类型的变化，从而提高准确性同时保持在相同架构设备上的可移植性。与传统和多量子比特深度相比，基于门的深度在任务(1)中将平均相对误差减少了68倍和18倍，并在任务(2)中将正确识别的平均数量增加了20个百分点和43个百分点。最后，我们为当前IBM Eagle和Heron架构提供了基于门的深度权重配置。
                </div>
                <a href="https://arxiv.org/abs/2505.16908" class="link">https://arxiv.org/abs/2505.16908</a>
                <div class="comment-section">
                    <h3>评论</h3>
                    <input type="text" class="comment-input" id="comment-input-23" placeholder="输入评论">
                    <button class="comment-button" onclick="addComment(23)">提交评论</button>
                    <ul class="comment-list" id="comment-list-23"></ul>
                </div>
                </div>
                
                <div class="literature-item" style="background-color: #fff;">
                <h2>Spin-qubit readout analysis based on a hidden Markov model</h2>
                <div class="authors">Maria Spethmann, Peter Stano, Daniel Loss</div>
                <div class="summary">
                摘要：在大多数量子比特平台上，读取保真度无法跟上门控保真度，因此正在寻找新的方法来提高读取保真度。对于半导体自旋量子比特来说，典型的量子比特读出信号由数字化电荷传感器输出的一段有限拉伸组成。通常会将此类信号跟踪压缩为单一值，即最大值或总和，然后通过将该单一值与固定的决策阈值进行比较来得到二进制测量结果。这种阈值方法虽然简单且快速，但忽略了可能提高读取保真度的潜在信息。本文分析了使用隐马尔可夫模型（HMM）进行更复杂信号跟踪处理可以实现什么。HMM是自然选择，因为它是在噪声为白噪声时的最优统计处理方法。此外，它还具有计算效率高的实现，即前向-后向算法，使得HMM处理在实际中可行。然而，与许多计算机模拟研究不同，在真实实验中，噪声是相关的。这种变化如何影响HMM的实施和可靠性是我们的主题。我们发现，使用白噪声作为系统统计模型的HMM对噪声相关性异常敏感；它只能容忍非常小的相关时间。我们建议通过信号预过滤来缓解这一缺陷。噪声相关性对HMM模型校准（Baum-Welch算法）产生了类似的强烈负面影响。此外，作为HMM的一个具体应用，我们计算了在提高温度时的读取保真度，这与最近针对热自旋量子比特的实验研究有
                </div>
                <a href="https://arxiv.org/abs/2505.19272" class="link">https://arxiv.org/abs/2505.19272</a>
                <div class="comment-section">
                    <h3>评论</h3>
                    <input type="text" class="comment-input" id="comment-input-24" placeholder="输入评论">
                    <button class="comment-button" onclick="addComment(24)">提交评论</button>
                    <ul class="comment-list" id="comment-list-24"></ul>
                </div>
                </div>
                
                <div class="literature-item" style="background-color: #fff;">
                <h2>Optimized quantum sensor networks for ultralight dark matter detection</h2>
                <div class="authors">Adriel I. Santoso, Le Bin Ho</div>
                <div class="summary">
                摘要：暗物质（DM）仍然是基础物理学中最具吸引力的未解问题之一，这激励了人们寻找新的探测方法。我们提出了基于网络的量子传感器架构，以增强对超轻暗物质场的灵敏度。该网络中的每个节点是一个超导量子比特，通过对称拓扑结构（如线、环、星和完全连接图）中的受控-Z门进行互联。我们研究了四量子比特和九量子比特系统，使用变分量子测量框架优化了状态准备和测量。这一方法通过最小化量子和经典Cramér-Rao下界来确定最佳配置。贝叶斯推断用于从测量结果中提取暗物质引起的相移。我们的结果表明，优化后的网络配置在保持适合噪声中间规模量子硬件的浅电路深度的同时，显著超越了传统的GHZ-based协议。此外，在局部去相位噪声下灵敏度仍然稳健。这些发现强调了网络结构在量子传感中的重要性，并指向了可扩展的增强暗物质探测的量子策略
                </div>
                <a href="https://arxiv.org/abs/2505.21188" class="link">https://arxiv.org/abs/2505.21188</a>
                <div class="comment-section">
                    <h3>评论</h3>
                    <input type="text" class="comment-input" id="comment-input-25" placeholder="输入评论">
                    <button class="comment-button" onclick="addComment(25)">提交评论</button>
                    <ul class="comment-list" id="comment-list-25"></ul>
                </div>
                </div>
                
                <div class="literature-item" style="background-color: #fff;">
                <h2>Fault tolerant Operations in Majorana-based Quantum Codes: Gates, Measurements and High Rate Constructions</h2>
                <div class="authors">Maryam Mudassar, Alexander Schuckert, Daniel Gottesman</div>
                <div class="summary">
                摘要：基于Majorana的量子计算在纳米线和中性原子中崛起，为编码量子比特并保护它们免受噪声干扰提供了一个有前途的平台。为了可靠地在此类设备上运行计算，需要为状态准备、门控和测量开发完全容错的方案。然而，当前的容错方案要么仅限于特定的码族，要么尚未完全开发。在这项工作中，我们开发了一个用于Majorana硬件的容错计算的一般框架，其中逻辑度被编码到Majorana设备中。我们强调了偶数和奇数Majorana代码之间的划分，以及在构建这些码族的容错小工具时这种划分是如何体现出来的。我们提供了横向构造，并用测量来补充，从而获得多个容错Clifford小工具的示例。对于奇数代码，我们使用量子参考系提供了一种新的小工具构造方法，该方法允许实现由于奇偶超选择禁止的操作。此外，我们还提供了受Steane纠错校正启发的Majorana码容错测量方案，使得可以准备状态、测量逻辑操作并进行纠错。我们还指出，对于奇数Majorana代码，可以构造具有横向T门的小工具。最后，我们构建了一个具有高码率的量子LDPC Majorana码，包含逻辑qubit。我们的工作表明，容错量子计算的所有必要元素都可以在诸如Majorana纳米线和费米中性原子等费米硬件中一致地实现。
                </div>
                <a href="https://arxiv.org/abs/2508.09928" class="link">https://arxiv.org/abs/2508.09928</a>
                <div class="comment-section">
                    <h3>评论</h3>
                    <input type="text" class="comment-input" id="comment-input-26" placeholder="输入评论">
                    <button class="comment-button" onclick="addComment(26)">提交评论</button>
                    <ul class="comment-list" id="comment-list-26"></ul>
                </div>
                </div>
                
                <div class="literature-item" style="background-color: #fff;">
                <h2>Cultivating T states on the surface code with only two-qubit gates</h2>
                <div class="authors">Jahan Claes</div>
                <div class="summary">
                摘要：高保真度T魔态是二维容错量子计算的关键要求。通常认为，准备高保真度T态需要噪声注入和漫长的蒸馏程序。这种假设最近被培育方法所挑战，其中仅使用谨慎的状态注入和后选择来准备接近量子算法所需保真度的T态。培育最初是为色码提出，但也可以在类似表面码的RP²码上进行。在本工作中，我们展示了如何直接在表面码上培育T态。除了与颜色或RP²培育相比的简单性之外，表面码培育还提供了一些优势：(1)它更直接地与中性原子架构兼容，而不是RP²培育;(2)培育出的表面码状态可以与其他表面码用于透版本CNOT门，这与颜色码不同;(3)表面码培育可以在任何距离进行，而颜色和RP²培育需要奇数距离。在标准去极化错误模型下，我们的d=3, (4), (5)培育电路达到1⋅10^{-6}, (1⋅10^{-8}), (2⋅10^{-9})的错误率和34%, (6%), (1%)的接受率，达到或超过颜色和RP²培育在相似接受率下的保真度。
                </div>
                <a href="https://arxiv.org/abs/2509.05232" class="link">https://arxiv.org/abs/2509.05232</a>
                <div class="comment-section">
                    <h3>评论</h3>
                    <input type="text" class="comment-input" id="comment-input-27" placeholder="输入评论">
                    <button class="comment-button" onclick="addComment(27)">提交评论</button>
                    <ul class="comment-list" id="comment-list-27"></ul>
                </div>
                </div>
                
                <div class="literature-item" style="background-color: #fff;">
                <h2>Perfect pure quantum state transfer via state restoring and ancilla measurement</h2>
                <div class="authors">E.B. Fel'dman, J. Wu, A.I. Zenchuk</div>
                <div class="summary">
                摘要：我们提出了一种用于在自旋-1/2链上传输任意纯量子态的完美状态转移协议，该链由保持系统内激发数不变的哈密顿量控制。我们展示了如何通过仅对扩展接收器的局部变换来恢复k-激发纯发送者状态。恢复后的状态与其他形成垃圾的状态以叠加形式出现，这些垃圾可以通过引入辅助系统（ancilla）来清除，辅助系统的状态标记了这些垃圾，并通过测量辅助系统的状态来获得所需的输出。接收者的最终状态与发送者的初始状态一致（忽略不重要的全局相位因子）。然后，为了传输任意纯态，我们将该状态编码为发送者的k-激发态，传输并恢复该状态，最后将接收器恢复的k-激发态解码为另一个子系统的状态。通过标记和清除辅助系统测量中的垃圾，我们完成了任意纯态完美传输的算法
                </div>
                <a href="https://arxiv.org/abs/2509.10100" class="link">https://arxiv.org/abs/2509.10100</a>
                <div class="comment-section">
                    <h3>评论</h3>
                    <input type="text" class="comment-input" id="comment-input-28" placeholder="输入评论">
                    <button class="comment-button" onclick="addComment(28)">提交评论</button>
                    <ul class="comment-list" id="comment-list-28"></ul>
                </div>
                </div>
                
                <div class="literature-item" style="background-color: #fff;">
                <h2>Towards a $\cos(2φ)$ Josephson element using aluminum junctions with well-transmitted channels</h2>
                <div class="authors">J. Griesmar, H. Riechert, M. Hantute, A. Peugeot, S. Annabi, Ç. Ö. Girit, G. O. Steffensen, A. L. Yeyati, E. Arrighi, L. Bretheau, J.-D. Pillet</div>
                <div class="summary">
                摘要：我们介绍了一种全铝约瑟夫森结的新型制造方法，该方法具有高度传导的导电通道。通常，这样的特性与复杂结构（如原子接触或基于半导体纳米线和二维材料的混合结）相关。相比之下，我们的方法仅依赖于标准的纳米加工技术。此外，我们提出了一种简单的超导电路设计，能够实现具有奇偶保护的量子比
                </div>
                <a href="https://arxiv.org/abs/2504.21494" class="link">https://arxiv.org/abs/2504.21494</a>
                <div class="comment-section">
                    <h3>评论</h3>
                    <input type="text" class="comment-input" id="comment-input-29" placeholder="输入评论">
                    <button class="comment-button" onclick="addComment(29)">提交评论</button>
                    <ul class="comment-list" id="comment-list-29"></ul>
                </div>
                </div>
                
                <div class="literature-item" style="background-color: #fff;">
                <h2>Ultra-long-living magnons in the quantum limit</h2>
                <div class="authors">Rostyslav O. Serha, Kaitlin H. McAllister, Fabian Majcen, Sebastian Knauer, Timmy Reimann, Carsten Dubs, Gennadii A. Melkov, Alexander A. Serga, Vasyl S. Tyberkevych, Andrii V. Chumak, Dmytro A. Bozhko</div>
                <div class="summary">
                摘要：这项研究探讨了固态量子系统中的相干时间，其与存储量子信息的能力直接相关。多年来，由于集体磁化动力学产生的磁子（一种拟粒子）的寿命在千兆赫频率下不足一微秒，使其作为量子信息载体的可行性受到限制。本研究报告了在毫克尔温温度下，短波长磁子的寿命超过18微秒。实验是在超纯单晶钇铁伽尼特（YIG）球上进行的，覆盖从常温到30毫开尔温的广泛温度范围。这一发现直接验证了理论预测，即在零温下理想YIG晶体中磁子的寿命是无限的，为设计无损耗的磁性系统铺平了道路，其中磁子将作为量子门和量子存储的长期信息载体。
                </div>
                <a href="https://arxiv.org/abs/2505.22773" class="link">https://arxiv.org/abs/2505.22773</a>
                <div class="comment-section">
                    <h3>评论</h3>
                    <input type="text" class="comment-input" id="comment-input-30" placeholder="输入评论">
                    <button class="comment-button" onclick="addComment(30)">提交评论</button>
                    <ul class="comment-list" id="comment-list-30"></ul>
                </div>
                </div>
                
        <script>
        function addComment(paperIndex) {
            const commentInput = document.getElementById(`comment-input-${paperIndex}`);
            const commentText = commentInput.value;
            if (commentText) {
                const commentList = document.getElementById(`comment-list-${paperIndex}`);
                const now = new Date();
                const timestamp = now.toLocaleString();
                const newComment = document.createElement('li');
                newComment.textContent = `${timestamp}: ${commentText}`;
                commentList.appendChild(newComment);
                // 保存评论到本地存储
                let comments = JSON.parse(localStorage.getItem(`comments-${paperIndex}`)) || [];
                comments.push(`${timestamp}: ${commentText}`);
                localStorage.setItem(`comments-${paperIndex}`, JSON.stringify(comments));
                commentInput.value = '';
            }
        }
        
        // 页面加载时显示本地存储的评论
        window.onload = function () {
            const comments0 = JSON.parse(localStorage.getItem(`comments-0`)) || []; const commentList0 = document.getElementById(`comment-list-0`); comments0.forEach(comment => { const newComment = document.createElement('li'); newComment.textContent = comment; commentList0.appendChild(newComment); });const comments1 = JSON.parse(localStorage.getItem(`comments-1`)) || []; const commentList1 = document.getElementById(`comment-list-1`); comments1.forEach(comment => { const newComment = document.createElement('li'); newComment.textContent = comment; commentList1.appendChild(newComment); });const comments2 = JSON.parse(localStorage.getItem(`comments-2`)) || []; const commentList2 = document.getElementById(`comment-list-2`); comments2.forEach(comment => { const newComment = document.createElement('li'); newComment.textContent = comment; commentList2.appendChild(newComment); });const comments3 = JSON.parse(localStorage.getItem(`comments-3`)) || []; const commentList3 = document.getElementById(`comment-list-3`); comments3.forEach(comment => { const newComment = document.createElement('li'); newComment.textContent = comment; commentList3.appendChild(newComment); });const comments4 = JSON.parse(localStorage.getItem(`comments-4`)) || []; const commentList4 = document.getElementById(`comment-list-4`); comments4.forEach(comment => { const newComment = document.createElement('li'); newComment.textContent = comment; commentList4.appendChild(newComment); });const comments5 = JSON.parse(localStorage.getItem(`comments-5`)) || []; const commentList5 = document.getElementById(`comment-list-5`); comments5.forEach(comment => { const newComment = document.createElement('li'); newComment.textContent = comment; commentList5.appendChild(newComment); });const comments6 = JSON.parse(localStorage.getItem(`comments-6`)) || []; const commentList6 = document.getElementById(`comment-list-6`); comments6.forEach(comment => { const newComment = document.createElement('li'); newComment.textContent = comment; commentList6.appendChild(newComment); });const comments7 = JSON.parse(localStorage.getItem(`comments-7`)) || []; const commentList7 = document.getElementById(`comment-list-7`); comments7.forEach(comment => { const newComment = document.createElement('li'); newComment.textContent = comment; commentList7.appendChild(newComment); });const comments8 = JSON.parse(localStorage.getItem(`comments-8`)) || []; const commentList8 = document.getElementById(`comment-list-8`); comments8.forEach(comment => { const newComment = document.createElement('li'); newComment.textContent = comment; commentList8.appendChild(newComment); });const comments9 = JSON.parse(localStorage.getItem(`comments-9`)) || []; const commentList9 = document.getElementById(`comment-list-9`); comments9.forEach(comment => { const newComment = document.createElement('li'); newComment.textContent = comment; commentList9.appendChild(newComment); });const comments10 = JSON.parse(localStorage.getItem(`comments-10`)) || []; const commentList10 = document.getElementById(`comment-list-10`); comments10.forEach(comment => { const newComment = document.createElement('li'); newComment.textContent = comment; commentList10.appendChild(newComment); });const comments11 = JSON.parse(localStorage.getItem(`comments-11`)) || []; const commentList11 = document.getElementById(`comment-list-11`); comments11.forEach(comment => { const newComment = document.createElement('li'); newComment.textContent = comment; commentList11.appendChild(newComment); });const comments12 = JSON.parse(localStorage.getItem(`comments-12`)) || []; const commentList12 = document.getElementById(`comment-list-12`); comments12.forEach(comment => { const newComment = document.createElement('li'); newComment.textContent = comment; commentList12.appendChild(newComment); });const comments13 = JSON.parse(localStorage.getItem(`comments-13`)) || []; const commentList13 = document.getElementById(`comment-list-13`); comments13.forEach(comment => { const newComment = document.createElement('li'); newComment.textContent = comment; commentList13.appendChild(newComment); });const comments14 = JSON.parse(localStorage.getItem(`comments-14`)) || []; const commentList14 = document.getElementById(`comment-list-14`); comments14.forEach(comment => { const newComment = document.createElement('li'); newComment.textContent = comment; commentList14.appendChild(newComment); });const comments15 = JSON.parse(localStorage.getItem(`comments-15`)) || []; const commentList15 = document.getElementById(`comment-list-15`); comments15.forEach(comment => { const newComment = document.createElement('li'); newComment.textContent = comment; commentList15.appendChild(newComment); });const comments16 = JSON.parse(localStorage.getItem(`comments-16`)) || []; const commentList16 = document.getElementById(`comment-list-16`); comments16.forEach(comment => { const newComment = document.createElement('li'); newComment.textContent = comment; commentList16.appendChild(newComment); });const comments17 = JSON.parse(localStorage.getItem(`comments-17`)) || []; const commentList17 = document.getElementById(`comment-list-17`); comments17.forEach(comment => { const newComment = document.createElement('li'); newComment.textContent = comment; commentList17.appendChild(newComment); });const comments18 = JSON.parse(localStorage.getItem(`comments-18`)) || []; const commentList18 = document.getElementById(`comment-list-18`); comments18.forEach(comment => { const newComment = document.createElement('li'); newComment.textContent = comment; commentList18.appendChild(newComment); });const comments19 = JSON.parse(localStorage.getItem(`comments-19`)) || []; const commentList19 = document.getElementById(`comment-list-19`); comments19.forEach(comment => { const newComment = document.createElement('li'); newComment.textContent = comment; commentList19.appendChild(newComment); });const comments20 = JSON.parse(localStorage.getItem(`comments-20`)) || []; const commentList20 = document.getElementById(`comment-list-20`); comments20.forEach(comment => { const newComment = document.createElement('li'); newComment.textContent = comment; commentList20.appendChild(newComment); });const comments21 = JSON.parse(localStorage.getItem(`comments-21`)) || []; const commentList21 = document.getElementById(`comment-list-21`); comments21.forEach(comment => { const newComment = document.createElement('li'); newComment.textContent = comment; commentList21.appendChild(newComment); });const comments22 = JSON.parse(localStorage.getItem(`comments-22`)) || []; const commentList22 = document.getElementById(`comment-list-22`); comments22.forEach(comment => { const newComment = document.createElement('li'); newComment.textContent = comment; commentList22.appendChild(newComment); });const comments23 = JSON.parse(localStorage.getItem(`comments-23`)) || []; const commentList23 = document.getElementById(`comment-list-23`); comments23.forEach(comment => { const newComment = document.createElement('li'); newComment.textContent = comment; commentList23.appendChild(newComment); });const comments24 = JSON.parse(localStorage.getItem(`comments-24`)) || []; const commentList24 = document.getElementById(`comment-list-24`); comments24.forEach(comment => { const newComment = document.createElement('li'); newComment.textContent = comment; commentList24.appendChild(newComment); });const comments25 = JSON.parse(localStorage.getItem(`comments-25`)) || []; const commentList25 = document.getElementById(`comment-list-25`); comments25.forEach(comment => { const newComment = document.createElement('li'); newComment.textContent = comment; commentList25.appendChild(newComment); });const comments26 = JSON.parse(localStorage.getItem(`comments-26`)) || []; const commentList26 = document.getElementById(`comment-list-26`); comments26.forEach(comment => { const newComment = document.createElement('li'); newComment.textContent = comment; commentList26.appendChild(newComment); });const comments27 = JSON.parse(localStorage.getItem(`comments-27`)) || []; const commentList27 = document.getElementById(`comment-list-27`); comments27.forEach(comment => { const newComment = document.createElement('li'); newComment.textContent = comment; commentList27.appendChild(newComment); });const comments28 = JSON.parse(localStorage.getItem(`comments-28`)) || []; const commentList28 = document.getElementById(`comment-list-28`); comments28.forEach(comment => { const newComment = document.createElement('li'); newComment.textContent = comment; commentList28.appendChild(newComment); });const comments29 = JSON.parse(localStorage.getItem(`comments-29`)) || []; const commentList29 = document.getElementById(`comment-list-29`); comments29.forEach(comment => { const newComment = document.createElement('li'); newComment.textContent = comment; commentList29.appendChild(newComment); });const comments30 = JSON.parse(localStorage.getItem(`comments-30`)) || []; const commentList30 = document.getElementById(`comment-list-30`); comments30.forEach(comment => { const newComment = document.createElement('li'); newComment.textContent = comment; commentList30.appendChild(newComment); });
        };
        </script>
        </body>
        </html>
        