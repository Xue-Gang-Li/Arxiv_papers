
        <!DOCTYPE html>
        <html lang="en">
        <head>
        <meta charset="UTF-8">
        <title>2025-09-18 Arxiv papers related with quantum computing overview</title>
        <style>
        
        body {
            font-family: Arial, sans-serif;
            line-height: 1.6;
            margin: 40px;
            background-color: #f5f5f5;
        }
        .literature-item {
            background-color: white;
            padding: 20px;
            margin-bottom: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }
        h2 {
            color: #333;
            font-size: 24px;
            margin-top: 0;
            padding-bottom: 10px;
            border-bottom: 3px solid #eee;
        }
        .authors {
            color: #666;
            font-style: italic;
            margin-bottom: 15px;
        }
        .summary {
            color: #444;
            text-align: justify;
        }
        .link {
            display: block;
            margin-top: 10px;
            font-size: 14px;
            color: #337ab7;
            text-decoration: none;
        }
        .comment-section {
            margin-top: 10px;
        }
        .comment-input {
            width: 80%;
            padding: 5px;
            margin-right: 5px;
        }
        .comment-button {
            padding: 5px 10px;
        }
        .comment-list {
            list-style-type: none;
            padding: 0;
            margin-top: 5px;
        }
        .comment-list li {
            border: 1px solid #eee;
            padding: 5px;
            margin-bottom: 3px;
        }
        
        </style>
        </head>
        <body>
        <h1>2025-09-18 Arxiv papers related with quantum computing overview</h1>
        
        <h1>Keywords: ['superconducting qubit', 'quantum error correction', 'superconducting circuit', 'surface code', 'transmon', 'quantum parity detection', 'quasiparticle', 'quantum sensor', 'charge parity']</h1>
        

                <div class="literature-item" style="background-color: #fff;">
                <h2>From virtual Z gates to virtual Z pulses</h2>
                <div class="authors">Christopher K. Long, Crispin H. W. Barnes</div>
                <div class="summary">
                摘要：虚拟Z门已成为实现快速、高保真度单量子比特操作的重要组成部分。然而，虚拟Z门要求系统的两量子比特门是微波激活或规范化单量子比特Z旋转——由X、SWAP和任意相位门生成的群。在本文中，我们将虚拟Z门的理论扩展到脉冲级别，这为门的设计和最近脉冲级别量子算法的进展提供了基础。这些算法尝试利用现有的噪声中间规模量子（NISQ）设备的全部潜力，通过消除与编译和翻译门相关的开销来实现。为了扩展虚拟Z门的理论，我们通过使用控制量子处理器的脉冲序列的时间膨胀，得出了一个平台无关的虚拟Z脉冲的理论框架。此外，我们提供了在半导体自旋量子比特和超导量子处理器架构上实现虚拟Z脉冲的实际例子。另外，我们还概述了硬件对虚拟Z脉冲的支持。我们发现，虚拟Z脉冲（因此虚拟Z门）可以在之前不支持虚拟Z门的硬件上使用。最后，我们介绍了虚拟Z脉冲在脉冲级算法中的两个额外应用。首先，扩展了可以以类比方式本地模拟的哈密顿量的类别。其次，提高了基于脉冲的变分量子算法的表达能力。
                </div>
                <a href="https://arxiv.org/abs/2509.13453" class="link">https://arxiv.org/abs/2509.13453</a>
                <div class="comment-section">
                    <h3>评论</h3>
                    <input type="text" class="comment-input" id="comment-input-0" placeholder="输入评论">
                    <button class="comment-button" onclick="addComment(0)">提交评论</button>
                    <ul class="comment-list" id="comment-list-0"></ul>
                </div>
                </div>
                
                <div class="literature-item" style="background-color: #fff;">
                <h2>End-to-End Complexity Analysis for Quantum Simulation of the Extended Jaynes-Cummings Models</h2>
                <div class="authors">Nam Nguyen, Michael Yu, Alan Robertson, Hiromichi Nishimura, Samuel J. Elman, Benjamin Koltenbah</div>
                <div class="summary">
                摘要：扩展的Jaynes-Cummings模型（eJCM）是一个描述多模式光物质相互作用的基本框架，在单光子添加和接近无噪声放大等量子技术中有直接应用。然而，该模型的复杂性使得经典模拟对于大型系统难以处理，这些系统在实际应用中可能很有趣。在这项工作中，我们提出了一种全面的端到端框架，用于对eJCM进行量子模拟。我们开发了使用第一和第二阶乘积公式的显式量子算法和电路，以模拟系统的时间演化，并分析了薛定谔和相互作用图景中的动力学。我们的分析包括指导模拟参数选择的严格、闭式误差边界，我们将这种方法扩展到高效处理纯态和混合态。此外，我们通过数值模拟验证了理论成本模型，并提供了详细的容错资源分析，将仿真电路编译到表面码架构，以得出物理比特数量和执行时间的具体估计。该工作为在未来量子计算机上模拟eJCM奠定了完整的蓝图。
                </div>
                <a href="https://arxiv.org/abs/2509.13546" class="link">https://arxiv.org/abs/2509.13546</a>
                <div class="comment-section">
                    <h3>评论</h3>
                    <input type="text" class="comment-input" id="comment-input-1" placeholder="输入评论">
                    <button class="comment-button" onclick="addComment(1)">提交评论</button>
                    <ul class="comment-list" id="comment-list-1"></ul>
                </div>
                </div>
                
                <div class="literature-item" style="background-color: #fff;">
                <h2>Rare Event Simulation of Quantum Error-Correcting Circuits</h2>
                <div class="authors">Carolyn Mayer, Anand Ganti, Uzoma Onunkwo, Tzvetan Metodi, Benjamin Anker, Jacek Skryzalin</div>
                <div class="summary">
                摘要：我们描述了一种实用的方法，用于在低物理（组件）故障率下评估量子纠错电路的逻辑故障率。标准蒙特卡罗方法通常是研究量子电路故障率的常用方法。然而，在研究容错纠错电路时，扩展此方法以达到低物理故障率是有限的。特别是在较大或具有高纠错能力的电路中，随着单个组件（逻辑门）输入故障率的降低，使用蒙特卡罗方法变得更加困难。因此，许多模拟研究的电路模型通常不会低于10^{-6}级别的端到端逻辑故障率。在本报告中，我们概述了一种借鉴Bravyi和Vargo早期工作并应用于更复杂噪声模型的方法。早期工作研究了容量和现象学噪声模型，但这些工作不足以生成类似于电路噪声模型的模拟。据我们所知，我们的小组是第一个为基于电路的噪声模型开发出稀有事件仿真技术分割方法的完整方案。我们还通过标准蒙特卡罗模拟在可访问的区域内获得了令人鼓舞的结果。这项工作表明，我们可以在量子纠错码的电路模型描述中接近10^{-20}级别的噪声。
                </div>
                <a href="https://arxiv.org/abs/2509.13678" class="link">https://arxiv.org/abs/2509.13678</a>
                <div class="comment-section">
                    <h3>评论</h3>
                    <input type="text" class="comment-input" id="comment-input-2" placeholder="输入评论">
                    <button class="comment-button" onclick="addComment(2)">提交评论</button>
                    <ul class="comment-list" id="comment-list-2"></ul>
                </div>
                </div>
                
                <div class="literature-item" style="background-color: #fff;">
                <h2>Quantum Utility in Simulating the Real-time Dynamics of the Fermi-Hubbard Model using Superconducting Quantum Computers</h2>
                <div class="authors">Talal Ahmed Chowdhury, Vladimir Korepin, Vincent R. Pascuzzi, Kwangmin Yu</div>
                <div class="summary">
                摘要：The Fermi-Hubbard model is a fundamental model in condensed matter physics that describes strongly correlated electrons. On the other hand, quantum computers are emerging as powerful tools for exploring the complex dynamics of these quantum many-body systems. In this work, we demonstrate the quantum simulation of the one-dimensional Fermi-Hubbard model using IBM's superconducting quantum computers, employing over 100 qubits. We introduce a first-order Trotterization scheme and extend it to an optimized second-order Trotterization for the time evolution in the Fermi-Hubbard model, specifically tailored for the limited qubit connectivity of quantum architectures, such as IBM's platforms. Notably, both Trotterization approaches are scalable and maintain a constant circuit depth at each Trotter step, regardless of the qubit count, enabling us to precisely investigate the relaxation dynamics in the Fermi-Hubbard model by measuring the expectation value of the Néel observable (staggered magnetization) for time-evolved quantum states. Finally, our successful measurement of expectation values in such large-scale quantum many-body systems, especially at longer time scales with larger entanglement, highlights the quantum utility of superconducting quantum platforms over conventional classical approximation methods.
                </div>
                <a href="https://arxiv.org/abs/2509.14196" class="link">https://arxiv.org/abs/2509.14196</a>
                <div class="comment-section">
                    <h3>评论</h3>
                    <input type="text" class="comment-input" id="comment-input-3" placeholder="输入评论">
                    <button class="comment-button" onclick="addComment(3)">提交评论</button>
                    <ul class="comment-list" id="comment-list-3"></ul>
                </div>
                </div>
                
                <div class="literature-item" style="background-color: #fff;">
                <h2>Effective delocalization in the one-dimensional Anderson model with stealthy disorder</h2>
                <div class="authors">Carlo Vanoni, Boris L. Altshuler, Paul J. Steinhardt, Salvatore Torquato</div>
                <div class="summary">
                摘要：我们分析和数值研究了一维带有"隐形"无序的Anderson模型，该模型定义为在连续波数带内消失的功率谱。受近期关于隐形超均匀分层介质光学透明性特性的研究启发，我们通过自能量的摊涂理论展开计算局域化长度。我们发现，对于固定的能量和小但有限的无序强度，存在任何有限长度系统的一个"隐形性"χ范围，其中局域化长度超过系统尺寸。这种"有效去局域化"是由于一种新的具有相关无序的结果，该无序跨越了连续的长度尺度范围，这是隐形系统的定义特征。此外，我们用数值模拟支持我们的分析结果。我们的结果可能成为研究量子系统中隐形无序作用的第一步，这对理论和实验都有重要意义。
                </div>
                <a href="https://arxiv.org/abs/2509.13502" class="link">https://arxiv.org/abs/2509.13502</a>
                <div class="comment-section">
                    <h3>评论</h3>
                    <input type="text" class="comment-input" id="comment-input-4" placeholder="输入评论">
                    <button class="comment-button" onclick="addComment(4)">提交评论</button>
                    <ul class="comment-list" id="comment-list-4"></ul>
                </div>
                </div>
                
                <div class="literature-item" style="background-color: #fff;">
                <h2>Hybrid Quantum-Classical Neural Networks for Few-Shot Credit Risk Assessment</h2>
                <div class="authors">Zheng-an Wang, Yanbo J. Wang, Jiachi Zhang, Qi Xu, Yilun Zhao, Jintao Li, Yipeng Zhang, Bo Yang, Xinkai Gao, Xiaofeng Cao, Kai Xu, Pengpeng Hao, Xuan Yang, Heng Fan</div>
                <div class="summary">
                摘要：量子机器学习（QML）为解决经典方法难以应对的复杂金融问题提供了一种新的范式。本研究特别针对少样本信用风险评估这一挑战，这是包容性金融中的一个关键问题，其中数据稀缺和不平衡限制了传统模型的有效性。为了解决这个问题，我们设计并实现了一种新型的混合量子-经典工作流程。该方法首先采用一组经典机器学习模型（逻辑回归、随机森林、XGBoost）进行智能特征工程和降维，然后通过参数偏移规则训练的量子神经网络（QNN）作为核心分类器。此框架通过数值模拟进行了评估，并部署在了Quafu Quantum Cloud Platform的ScQ-P21超导处理器上。在279个样本的真实信用数据集上，我们的QNN在模拟中实现了稳健的平均AUC值0.852 ± 0.027，在硬件实验中获得了令人印象深刻的AUC值0.88。此性能超过了一系列经典基准，特别是在召回指标上表现尤为突出。该研究为NISQ时代中的数据受限金融场景提供了量子计算应用的切实蓝图，并提供了有价值的实证证据以支持其在高风险应用（如包容性金融）中的潜力。
                </div>
                <a href="https://arxiv.org/abs/2509.13818" class="link">https://arxiv.org/abs/2509.13818</a>
                <div class="comment-section">
                    <h3>评论</h3>
                    <input type="text" class="comment-input" id="comment-input-5" placeholder="输入评论">
                    <button class="comment-button" onclick="addComment(5)">提交评论</button>
                    <ul class="comment-list" id="comment-list-5"></ul>
                </div>
                </div>
                
                <div class="literature-item" style="background-color: #fff;">
                <h2>Non-Clifford and parallelizable fault-tolerant logical gates on constant and almost-constant rate homological quantum LDPC codes via higher symmetries</h2>
                <div class="authors">Guanyu Zhu, Shehryar Sikander, Elia Portnoy, Andrew W. Cross, Benjamin J. Brown</div>
                <div class="summary">
                摘要：我们研究了在3-manifold上定义的同态量子低密度奇偶校验（LDPC）码家族的并行容错量子计算，具有恒定或几乎恒定的编码率。我们推导了一般3-manifold上颜色码的跨单T门的通用公式，它在任何三联逻辑qubit上充当集体非Clifford逻辑CCZ门，其逻辑-X膜在一个点具有$\mathbb{Z}_2$三交。三交数是一个拓扑不变量，也出现在拓扑量子场论中的出现的高级对称性操作符的路径积分中：$\mathbb{Z}_2^3$规范理论。此外，颜色码的跨单S门对应于支持在一次子流形上的高形式对称性，从而产生指数数量可寻址和并行化的逻辑CZ门。通过杯积上同操作，我们还展示了在任意3-manifold上构建三份相同toric码的恒定深度逻辑门电路。我们开发了一种计算3-manifold三交不变量的通用公式。进一步，我们开发了支持此类逻辑门的三种LDPC码：（1）从2D双曲面和一个圆的乘积中获得的拟超双曲代码，几乎恒定速率$k/n=O(1/\log(n))$和$O(\log(n))$距离；（2）具有速率$O(1/\log^{\frac{1}{2}}(n))$和距离$O(\log^{\frac{1}{2}}(n))$的同态纤维束代码；（3）特定的3D双曲代码家族：Torelli映射torus代码，由Torelli子群中的伪Anosov元素的映射tori构建，具有恒定速率，而距离缩放目前尚未知。然后我们展示了一种使用逻辑-X测量辅助应用并行化通用门集的通用恒定开销方案。
                </div>
                <a href="https://arxiv.org/abs/2310.16982" class="link">https://arxiv.org/abs/2310.16982</a>
                <div class="comment-section">
                    <h3>评论</h3>
                    <input type="text" class="comment-input" id="comment-input-6" placeholder="输入评论">
                    <button class="comment-button" onclick="addComment(6)">提交评论</button>
                    <ul class="comment-list" id="comment-list-6"></ul>
                </div>
                </div>
                
                <div class="literature-item" style="background-color: #fff;">
                <h2>Exploring the Potential of Quantum Approximate Optimization Algorithm in Tackling the Perfect Domination Problem</h2>
                <div class="authors">Haoqian Pan, Changhong Lu, Yuqing Zheng, Chunxing Yan</div>
                <div class="summary">
                摘要：完美支配问题（PDP）是一个经典的组合优化难题，在错误纠正码、无线通信网络和社交网络等现实系统中有重要应用。几十年的研究已经充分证明了其在众多图类上的NP完全性。受量子计算快速发展的启发，近年来大量研究致力于针对NP完全问题的量子算法，其中最著名的是量子近似优化算法（QAOA）。然而，基于量子的方法对PDP的应用性和有效性尚未得到充分探索。本文首次系统地通过QAOA对PDP进行研究。我们在6、7和8个顶点的三个基准实例上使用15-18个量子比特评估了解决方案的质量，检查了超过400种不同的参数配置。实验结果证实了算法的有效性并揭示了参数选择中的明显趋势。这些成果证明了QAOA在PDP上的可行性，并标志着将这一经典问题置于量子计算范式中的重要一步。
                </div>
                <a href="https://arxiv.org/abs/2411.12608" class="link">https://arxiv.org/abs/2411.12608</a>
                <div class="comment-section">
                    <h3>评论</h3>
                    <input type="text" class="comment-input" id="comment-input-7" placeholder="输入评论">
                    <button class="comment-button" onclick="addComment(7)">提交评论</button>
                    <ul class="comment-list" id="comment-list-7"></ul>
                </div>
                </div>
                
                <div class="literature-item" style="background-color: #fff;">
                <h2>Resonator-assisted quantum transduction between superconducting qubits and trapped atomic systems via Rydberg levels</h2>
                <div class="authors">Fernando L. Semião, Matthias Keller</div>
                <div class="summary">
                摘要：我们提出了一种利用共用微波谐振器实现超导量子比特和原子系统中编码在低能级内部状态的qubit态之间的传输方案。该方法同时使用了原子的Rydberg能级和将其与低能级qubit态连接起来的激光脉冲。我们探讨了两种耦合协议：一种基于子系统之间的谐振相互作用，另一种在不散发调节下工作，此时谐振器远离物质qubit的跃迁频率。这些协议使得从超导量子比特到原子qubit的一般qubit态传输成为可能。在不同的耦合调节和各种失散和去相干源（包括谐振器衰减、Rydberg态衰减以及超导量子比特的弛豫和纯去相位）下，评估了传输保真度，并对所提出的方案的性能进行了详细评估。
                </div>
                <a href="https://arxiv.org/abs/2501.03201" class="link">https://arxiv.org/abs/2501.03201</a>
                <div class="comment-section">
                    <h3>评论</h3>
                    <input type="text" class="comment-input" id="comment-input-8" placeholder="输入评论">
                    <button class="comment-button" onclick="addComment(8)">提交评论</button>
                    <ul class="comment-list" id="comment-list-8"></ul>
                </div>
                </div>
                
                <div class="literature-item" style="background-color: #fff;">
                <h2>Area and volume as emergent phenomena from entangled qubits</h2>
                <div class="authors">Juan M. Romero, Emiliano Montoya-González</div>
                <div class="summary">
                摘要：最近，几何量与量子信息理论之间的某些联系已被揭示。在本文中，我们证明了几何量，如面积和体积，可以直接从纠缠的多量子比特态中产生。特别是，二维平行四边形的面积来源于4个量子比特的纠缠态，三维平行四边形的矢量面积来自3个6量子比特的纠缠态，而三维平行六面体的体积来自9个量子比特的纠缠态。使用Qiskit构建并实现相应的量子电路以生成所需的纠缠态。鉴于平行四边形和平行六面体是更复杂几何结构的基本组成部分，这些结果可能提供了一种探索量子信息框架中潜在几何的途径。
                </div>
                <a href="https://arxiv.org/abs/2505.11487" class="link">https://arxiv.org/abs/2505.11487</a>
                <div class="comment-section">
                    <h3>评论</h3>
                    <input type="text" class="comment-input" id="comment-input-9" placeholder="输入评论">
                    <button class="comment-button" onclick="addComment(9)">提交评论</button>
                    <ul class="comment-list" id="comment-list-9"></ul>
                </div>
                </div>
                
                <div class="literature-item" style="background-color: #fff;">
                <h2>Quantum Imaginary-Time Evolution with Polynomial Resources in Time</h2>
                <div class="authors">Lei Zhang, Jizhe Lai, Xian Wu, Xin Wang</div>
                <div class="summary">
                摘要：虚拟时间演化在分析量子多体系统中是基本的，但经典模拟需要随着系统规模和演化时间呈指数增长的资源。尽管量子方法减少了系统规模的复杂度，但现有的方法依赖于启发式技术，这些技术的测量精度或成功概率会随着演化时间的增加而下降。我们提出了一种量子算法，使用自适应归一化因子来准备标准化的虚拟时间演化态，从而在较大的虚拟时间内保持稳定的成功概率。我们的算法在反向虚拟时间内以多项式小的错误近似目标状态，使用多项式数量的基本量子门和一个辅助量子比特，在接近1的成功概率下实现。此外，当初始态与基态有合理重叠时，该算法在系统规模上也具有多项式资源复杂度。我们将这种方法扩展到基态准备和基态能量估计，相较于现有的方法，电路深度减少。数值实验验证了我们的理论结果，对演化时间长达50的证明有效，展示了该算法在长时间演化中的有效性及其在早期容错量子计算中的潜在应用。
                </div>
                <a href="https://arxiv.org/abs/2507.00908" class="link">https://arxiv.org/abs/2507.00908</a>
                <div class="comment-section">
                    <h3>评论</h3>
                    <input type="text" class="comment-input" id="comment-input-10" placeholder="输入评论">
                    <button class="comment-button" onclick="addComment(10)">提交评论</button>
                    <ul class="comment-list" id="comment-list-10"></ul>
                </div>
                </div>
                
                <div class="literature-item" style="background-color: #fff;">
                <h2>Excitonic Coupling and Photon Antibunching in Venus Yellow Fluorescent Protein Dimers: A Lindblad Master Equation Approach</h2>
                <div class="authors">Ian T. Abrahams</div>
                <div class="summary">
                摘要：强激子的耦合和光子反积累（AB）现象已同时被观察到存在于Venus黄色荧光蛋白二聚体中，但目前仍缺乏一个全面的理论解释。在2019年，Kim等人在圆二色谱中展示了Davydov分裂，这表明存在强J型耦合，而通过结合反积累/荧光相关光谱法（AB/FCS指纹识别）证实了抗积累的荧光发射。为了探究这种共存的意义，Venus二聚体的群体动力学被建模于Lindblad大师方程框架内，这是由于特征耦合、去相位和热弛豁速率的分离而得以证明。模拟预测快速失相干，将亮暗态混合物与室温下的抗积累荧光发射一致。因此，激子耦合和光子AB在无需长寿命量子相干的情况下实现了调和。更广泛地说，荧光蛋白已成为可行的模型系统，用于探究染色蛋白光物理和量子动力学上的进化压力。低温冷却可能将相干时间延伸到满足超快门操作所需的范围内，这表明荧光蛋白二聚体作为生物启发的量子比特平台是可行的。
                </div>
                <a href="https://arxiv.org/abs/2508.14233" class="link">https://arxiv.org/abs/2508.14233</a>
                <div class="comment-section">
                    <h3>评论</h3>
                    <input type="text" class="comment-input" id="comment-input-11" placeholder="输入评论">
                    <button class="comment-button" onclick="addComment(11)">提交评论</button>
                    <ul class="comment-list" id="comment-list-11"></ul>
                </div>
                </div>
                
                <div class="literature-item" style="background-color: #fff;">
                <h2>Towards a $\cos(2φ)$ Josephson element using aluminum junctions with well-transmitted channels</h2>
                <div class="authors">J. Griesmar, H. Riechert, M. Hantute, A. Peugeot, S. Annabi, Ç. Ö. Girit, G. O. Steffensen, A. L. Yeyati, E. Arrighi, L. Bretheau, J.-D. Pillet</div>
                <div class="summary">
                摘要：我们介绍了一种新颖的全铝约瑟夫森结制造方法，这些结具有高度传导通道。通过常规纳微制造技术，所得器件在电流-电压特性中显示出多次安德列夫反射，同时提出了一种基于这些结的超导电路设计，以实现带有奇偶保护的量子比特。
                </div>
                <a href="https://arxiv.org/abs/2504.21494" class="link">https://arxiv.org/abs/2504.21494</a>
                <div class="comment-section">
                    <h3>评论</h3>
                    <input type="text" class="comment-input" id="comment-input-12" placeholder="输入评论">
                    <button class="comment-button" onclick="addComment(12)">提交评论</button>
                    <ul class="comment-list" id="comment-list-12"></ul>
                </div>
                </div>
                
                <div class="literature-item" style="background-color: #fff;">
                <h2>Growth of block diagonal operators and symmetry-resolved Krylov complexity</h2>
                <div class="authors">Pawel Caputa, Giuseppe Di Giulio, Tran Quang Loc</div>
                <div class="summary">
                摘要：这项工作探讨了不变算子的增长如何受到其潜在对称性结构的影响。为此，我们引入了对称性解析的Krylov复杂度，该复杂度捕捉了在给定对称性下不变算子分解后的各个块随时间演化的情况。我们发现，在早期，整个算子的复杂度等于对称性解析贡献的平均值。然而，在后期，不同charge sector之间的相互作用变得更加错综复杂。一般来说，对称性解析的Krylov复杂度取决于charge sector，但在某些情况下，这种依赖关系消失，导致Krylov复杂度的一种均分配形式。我们的分析为对称性结构在研究Krylov空间复杂性的更广泛应用奠定了基础，并对多体量子系统中的热化和普遍性具有影响。
                </div>
                <a href="https://arxiv.org/abs/2507.02033" class="link">https://arxiv.org/abs/2507.02033</a>
                <div class="comment-section">
                    <h3>评论</h3>
                    <input type="text" class="comment-input" id="comment-input-13" placeholder="输入评论">
                    <button class="comment-button" onclick="addComment(13)">提交评论</button>
                    <ul class="comment-list" id="comment-list-13"></ul>
                </div>
                </div>
                
                <div class="literature-item" style="background-color: #fff;">
                <h2>Enhanced Rényi Entropy-Based Post-Quantum Key Agreement with Provable Security and Information-Theoretic Guarantees</h2>
                <div class="authors">Ruopengyu Xu, Chenglian Liu</div>
                <div class="summary">
                
                </div>
                <a href="https://arxiv.org/abs/2509.00104" class="link">https://arxiv.org/abs/2509.00104</a>
                <div class="comment-section">
                    <h3>评论</h3>
                    <input type="text" class="comment-input" id="comment-input-14" placeholder="输入评论">
                    <button class="comment-button" onclick="addComment(14)">提交评论</button>
                    <ul class="comment-list" id="comment-list-14"></ul>
                </div>
                </div>
                
        <script>
        function addComment(paperIndex) {
            const commentInput = document.getElementById(`comment-input-${paperIndex}`);
            const commentText = commentInput.value;
            if (commentText) {
                const commentList = document.getElementById(`comment-list-${paperIndex}`);
                const now = new Date();
                const timestamp = now.toLocaleString();
                const newComment = document.createElement('li');
                newComment.textContent = `${timestamp}: ${commentText}`;
                commentList.appendChild(newComment);
                // 保存评论到本地存储
                let comments = JSON.parse(localStorage.getItem(`comments-${paperIndex}`)) || [];
                comments.push(`${timestamp}: ${commentText}`);
                localStorage.setItem(`comments-${paperIndex}`, JSON.stringify(comments));
                commentInput.value = '';
            }
        }
        
        // 页面加载时显示本地存储的评论
        window.onload = function () {
            const comments0 = JSON.parse(localStorage.getItem(`comments-0`)) || []; const commentList0 = document.getElementById(`comment-list-0`); comments0.forEach(comment => { const newComment = document.createElement('li'); newComment.textContent = comment; commentList0.appendChild(newComment); });const comments1 = JSON.parse(localStorage.getItem(`comments-1`)) || []; const commentList1 = document.getElementById(`comment-list-1`); comments1.forEach(comment => { const newComment = document.createElement('li'); newComment.textContent = comment; commentList1.appendChild(newComment); });const comments2 = JSON.parse(localStorage.getItem(`comments-2`)) || []; const commentList2 = document.getElementById(`comment-list-2`); comments2.forEach(comment => { const newComment = document.createElement('li'); newComment.textContent = comment; commentList2.appendChild(newComment); });const comments3 = JSON.parse(localStorage.getItem(`comments-3`)) || []; const commentList3 = document.getElementById(`comment-list-3`); comments3.forEach(comment => { const newComment = document.createElement('li'); newComment.textContent = comment; commentList3.appendChild(newComment); });const comments4 = JSON.parse(localStorage.getItem(`comments-4`)) || []; const commentList4 = document.getElementById(`comment-list-4`); comments4.forEach(comment => { const newComment = document.createElement('li'); newComment.textContent = comment; commentList4.appendChild(newComment); });const comments5 = JSON.parse(localStorage.getItem(`comments-5`)) || []; const commentList5 = document.getElementById(`comment-list-5`); comments5.forEach(comment => { const newComment = document.createElement('li'); newComment.textContent = comment; commentList5.appendChild(newComment); });const comments6 = JSON.parse(localStorage.getItem(`comments-6`)) || []; const commentList6 = document.getElementById(`comment-list-6`); comments6.forEach(comment => { const newComment = document.createElement('li'); newComment.textContent = comment; commentList6.appendChild(newComment); });const comments7 = JSON.parse(localStorage.getItem(`comments-7`)) || []; const commentList7 = document.getElementById(`comment-list-7`); comments7.forEach(comment => { const newComment = document.createElement('li'); newComment.textContent = comment; commentList7.appendChild(newComment); });const comments8 = JSON.parse(localStorage.getItem(`comments-8`)) || []; const commentList8 = document.getElementById(`comment-list-8`); comments8.forEach(comment => { const newComment = document.createElement('li'); newComment.textContent = comment; commentList8.appendChild(newComment); });const comments9 = JSON.parse(localStorage.getItem(`comments-9`)) || []; const commentList9 = document.getElementById(`comment-list-9`); comments9.forEach(comment => { const newComment = document.createElement('li'); newComment.textContent = comment; commentList9.appendChild(newComment); });const comments10 = JSON.parse(localStorage.getItem(`comments-10`)) || []; const commentList10 = document.getElementById(`comment-list-10`); comments10.forEach(comment => { const newComment = document.createElement('li'); newComment.textContent = comment; commentList10.appendChild(newComment); });const comments11 = JSON.parse(localStorage.getItem(`comments-11`)) || []; const commentList11 = document.getElementById(`comment-list-11`); comments11.forEach(comment => { const newComment = document.createElement('li'); newComment.textContent = comment; commentList11.appendChild(newComment); });const comments12 = JSON.parse(localStorage.getItem(`comments-12`)) || []; const commentList12 = document.getElementById(`comment-list-12`); comments12.forEach(comment => { const newComment = document.createElement('li'); newComment.textContent = comment; commentList12.appendChild(newComment); });const comments13 = JSON.parse(localStorage.getItem(`comments-13`)) || []; const commentList13 = document.getElementById(`comment-list-13`); comments13.forEach(comment => { const newComment = document.createElement('li'); newComment.textContent = comment; commentList13.appendChild(newComment); });const comments14 = JSON.parse(localStorage.getItem(`comments-14`)) || []; const commentList14 = document.getElementById(`comment-list-14`); comments14.forEach(comment => { const newComment = document.createElement('li'); newComment.textContent = comment; commentList14.appendChild(newComment); });
        };
        </script>
        </body>
        </html>
        