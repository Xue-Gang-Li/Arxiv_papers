
        <!DOCTYPE html>
        <html lang="en">
        <head>
        <meta charset="UTF-8">
        <title>2025-10-29 Arxiv papers related with quantum computing overview</title>
        <style>
        
        body {
            font-family: Arial, sans-serif;
            line-height: 1.6;
            margin: 40px;
            background-color: #f5f5f5;
        }
        .literature-item {
            background-color: white;
            padding: 20px;
            margin-bottom: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }
        h2 {
            color: #333;
            font-size: 24px;
            margin-top: 0;
            padding-bottom: 10px;
            border-bottom: 3px solid #eee;
        }
        .authors {
            color: #666;
            font-style: italic;
            margin-bottom: 15px;
        }
        .summary {
            color: #444;
            text-align: justify;
        }
        .link {
            display: block;
            margin-top: 10px;
            font-size: 14px;
            color: #337ab7;
            text-decoration: none;
        }
        .comment-section {
            margin-top: 10px;
        }
        .comment-input {
            width: 80%;
            padding: 5px;
            margin-right: 5px;
        }
        .comment-button {
            padding: 5px 10px;
        }
        .comment-list {
            list-style-type: none;
            padding: 0;
            margin-top: 5px;
        }
        .comment-list li {
            border: 1px solid #eee;
            padding: 5px;
            margin-bottom: 3px;
        }
        
        </style>
        </head>
        <body>
        <h1>2025-10-29 Arxiv papers related with quantum computing overview</h1>
        
        <h1>Keywords: ['superconducting qubit', 'quantum error correction', 'superconducting circuit', 'surface code', 'transmon', 'quantum parity detection', 'quasiparticle', 'quantum sensor', 'charge parity']</h1>
        

                <div class="literature-item" style="background-color: #fff;">
                <h2>The injective norm of CSS quantum error-correcting codes</h2>
                <div class="authors">Stephane Dartois, Gilles Zémor</div>
                <div class="summary">
                摘要：在本文中，我们计算了CSS量子纠错码标准基态的注入范数，也就是几何纠缠。一个量子状态的注入范数是真正多方纠缠的度量。通常情况下，计算这一度量具有NP难性。然而，在凝聚态理论中，特别是在拓扑相的背景下，对于Kitaev码及其扩展，Orús和他的合作者已经精确地计算了这个值。我们将这些结果扩展到所有CSS码，从而获得一个非平凡、无限家族量子状态的注入范数。在此过程中，我们发现了一种有趣的关系，即与matroid理论和Edmonds的交集定理。
                </div>
                <a href="https://arxiv.org/abs/2510.23736" class="link">https://arxiv.org/abs/2510.23736</a>
                <div class="comment-section">
                    <h3>评论</h3>
                    <input type="text" class="comment-input" id="comment-input-0" placeholder="输入评论">
                    <button class="comment-button" onclick="addComment(0)">提交评论</button>
                    <ul class="comment-list" id="comment-list-0"></ul>
                </div>
                </div>
                
                <div class="literature-item" style="background-color: #fff;">
                <h2>Estimating and decoding coherent errors of QEC experiments with detector error models</h2>
                <div class="authors">Evangelia Takou, Kenneth R. Brown</div>
                <div class="summary">
                摘要：量子误差纠正（QEC）实验中的解码器基于检测到的错误以及预期的错误事件率做出决策，这两者共同构成了一个探测器错误模型。在这里，我们展示了QEC实验中的综合征历史足以检测和估计相干性错误，从而消除了对先前设备基准测试实验的需求。重要的是，我们的方法表明，基于实验确定的探测器错误模型在随机噪声和相干噪声两种情况下同样有效。我们通过使用Majorana和Monte Carlo模拟器，对重复码和表面码以及各种现象学和电路级噪声场景建模，以处理全相干或全随机的噪声。我们捕获了相干错误的干涉，这在物理错误率上表现为增强或抑制，相较于随机情况，并且还观察到了不出现在对应Pauli-twirled模型中的超边。最后，我们解码了在经历相干噪声的情况下探测器错误模型，并发现与基于随机噪声假设构建的探测器错误模型相比，阈值不同。
                </div>
                <a href="https://arxiv.org/abs/2510.23797" class="link">https://arxiv.org/abs/2510.23797</a>
                <div class="comment-section">
                    <h3>评论</h3>
                    <input type="text" class="comment-input" id="comment-input-1" placeholder="输入评论">
                    <button class="comment-button" onclick="addComment(1)">提交评论</button>
                    <ul class="comment-list" id="comment-list-1"></ul>
                </div>
                </div>
                
                <div class="literature-item" style="background-color: #fff;">
                <h2>Differential magnetometry with partially flipped Dicke states</h2>
                <div class="authors">Iagoba Apellaniz, Manuel Gessner, Géza Tóth</div>
                <div class="summary">
                摘要：我们研究了使用两个空间分离的自旋系综来测量磁梯度和均匀背景场在三个空间轴上的情况。我们得到了这些参数可实现估计精度的权衡关系式。Dicke态，适用于均匀场估计，可以通过旋转子集中的自旋将其变为对磁梯度敏感的状态。我们确定了三正交方向上梯度测量精度的界限，这些界限是关于各个方向均匀场灵敏度的函数。所得到的部分翻转的Dicke态达到了上述界限，在两个方向显示出相似的灵敏度，但在第三个方向灵敏度显著降低。利用两组系综之间的纠缠，这种状态实现了大约是最佳二分可分态（局部Dicke态的乘积）所能达到的精度的两倍。对于小型系综，我们明确识别出达到量子Cramér-Rao界限的测量算符，而对于较大的系综，我们提出了一些次优但更简单的方案。在这两种情况下，梯度都通过角动量算符的二阶矩和相关性来估计。我们的结果展示了如何利用Dicke态的测量特性来实现增强的多参数量子估计
                </div>
                <a href="https://arxiv.org/abs/2510.23815" class="link">https://arxiv.org/abs/2510.23815</a>
                <div class="comment-section">
                    <h3>评论</h3>
                    <input type="text" class="comment-input" id="comment-input-2" placeholder="输入评论">
                    <button class="comment-button" onclick="addComment(2)">提交评论</button>
                    <ul class="comment-list" id="comment-list-2"></ul>
                </div>
                </div>
                
                <div class="literature-item" style="background-color: #fff;">
                <h2>A Scalable Superconducting Circuit Framework for Emulating Physics in Hyperbolic Space</h2>
                <div class="authors">Xicheng Xu, Ahmed Adel Mahmoud, Noah Gorgichuk, Ronny Thomale, Steven Rayan, Matteo Mariantoni</div>
                <div class="summary">
                摘要：理论研究和过去六年的实验证明，通过合成负曲率空间的工程方法，可以在设备物理学中揭示新行为和功能。例如，最近在双曲带理论方面的发展揭示了高维本征态的出现，这是传统欧几里得系统所不具备的基本特性。同时，超导量子电路已成为领先的平台，用于在可扩展架构中进行量子模拟和数字模拟。在这里，我们介绍了一种可扩展的超导电路框架，用于模拟双曲线和Kagome晶格上的紧束缚模型。通过这种方法，我们实验实现了三个不同的晶格，包括我们所知的第一次实现的居住在属数3黎曼曲面的双曲晶格。我们的方法将双曲度量直接编码到高质量超导谐振器之间的电容耦合中，使得光谱和定位特性的可持续再生产成为可能，同时克服了先前设计中的重大扩展性和光谱分辨率限制。这一结果为大规模实验研究双曲物质在凝聚态物理学奠定了基础，并为实现双曲线量子处理器铺平了道路，这对基础物理和量子计算都有潜在的影
                </div>
                <a href="https://arxiv.org/abs/2510.23827" class="link">https://arxiv.org/abs/2510.23827</a>
                <div class="comment-section">
                    <h3>评论</h3>
                    <input type="text" class="comment-input" id="comment-input-3" placeholder="输入评论">
                    <button class="comment-button" onclick="addComment(3)">提交评论</button>
                    <ul class="comment-list" id="comment-list-3"></ul>
                </div>
                </div>
                
                <div class="literature-item" style="background-color: #fff;">
                <h2>Clifford Transformations for Fermionic Quantum Systems: From Paulis to Majoranas to Fermions</h2>
                <div class="authors">Ilias Magoulas, Francesco A. Evangelista</div>
                <div class="summary">
                摘要：Clifford门和变换是量子计算中的基础，其映射基本Pauli或Majorana操作符的乘积到其他乘积，在稳定器形式、误差校正代码、中间态蒸馏、量子通信与密码学以及qubit裁剪等方面具有重要作用。此外，完全由Clifford门组成的电路在经典上是可模拟的，这突出了它们的计算意义。在这项工作中，我们将Clifford变换的概念扩展到费米系统。我们证明了费米Clifford变换由半体和对操作生成，并提供了一种系统的框架用于其特征化。此外，我们建立了与费米平均场理论的联系，并在qubit裁剪中的应用，提供了它们在量子计算中更广泛影响的见解。
                </div>
                <a href="https://arxiv.org/abs/2510.23923" class="link">https://arxiv.org/abs/2510.23923</a>
                <div class="comment-section">
                    <h3>评论</h3>
                    <input type="text" class="comment-input" id="comment-input-4" placeholder="输入评论">
                    <button class="comment-button" onclick="addComment(4)">提交评论</button>
                    <ul class="comment-list" id="comment-list-4"></ul>
                </div>
                </div>
                
                <div class="literature-item" style="background-color: #fff;">
                <h2>Nonreciprocity enhanced Quantum Gyroscopes based on Surface Acoustic Waves</h2>
                <div class="authors">Y.T.Zhu, Shibei Xue, Fangfang Ju, Haidong Yuan</div>
                <div class="summary">
                摘要：这篇文章探讨了表面声波（SAWs）在低泵浦功率下的量子相干现象及其在量子陀螺仪中的应用。通过多点耦合，实现了非互易转移，从而提高了信噪比和灵敏度，为量子传感技术的发展提供了重要支
                </div>
                <a href="https://arxiv.org/abs/2510.23996" class="link">https://arxiv.org/abs/2510.23996</a>
                <div class="comment-section">
                    <h3>评论</h3>
                    <input type="text" class="comment-input" id="comment-input-5" placeholder="输入评论">
                    <button class="comment-button" onclick="addComment(5)">提交评论</button>
                    <ul class="comment-list" id="comment-list-5"></ul>
                </div>
                </div>
                
                <div class="literature-item" style="background-color: #fff;">
                <h2>Exploiting biased noise in variational quantum models</h2>
                <div class="authors">Connor van Rossum, Sally Shrapnel, Riddhi Gupta</div>
                <div class="summary">
                摘要：变分量子算法（VQAs）是展示近期量子硬件量子实用性的有希望的工具，应用于优化、量子模拟和机器学习。尽管研究人员已经研究了VQA的训练难易程度，但量子噪声对经典优化过程的影响仍不太清楚。与预期相反，我们发现在标准误差减少策略中常用的twirling实际上会降低变分环境中的性能，而保留有偏差或非单元性的噪声可以帮助经典优化器找到更好的解决方案。从分析上来看，我们研究了一个通用量子回归模型，并证明相对均匀的Pauli信道抑制了梯度大小并降低了表达能力，使得优化更加困难。相反，例如幅度衰减或有偏的Pauli信道等不对称噪声会引入方向偏差，可以在优化过程中加以利用。通过对变分特征求解器对转场Ising模型进行数值实验，我们确认非单元噪声产生的能量状态较低twirled噪声。最后，我们证明了相位错误可以通过重新参数化完全缓解。这些发现挑战了传统的噪声减少策略，并表明保留噪声偏差可能会增强VQA性能。
                </div>
                <a href="https://arxiv.org/abs/2510.24050" class="link">https://arxiv.org/abs/2510.24050</a>
                <div class="comment-section">
                    <h3>评论</h3>
                    <input type="text" class="comment-input" id="comment-input-6" placeholder="输入评论">
                    <button class="comment-button" onclick="addComment(6)">提交评论</button>
                    <ul class="comment-list" id="comment-list-6"></ul>
                </div>
                </div>
                
                <div class="literature-item" style="background-color: #fff;">
                <h2>Fock space prethermalization and time-crystalline order on a quantum processor</h2>
                <div class="authors">Zehang Bao, Zitian Zhu, Yang-Ren Liu, Zixuan Song, Feitong Jin, Xuhao Zhu, Yu Gao, Chuanyu Zhang, Ning Wang, Yiren Zou, Ziqi Tan, Aosai Zhang, Zhengyi Cui, Fanhao Shen, Jiarun Zhong, Yiyang He, Han Wang, Jia-Nan Yang, Yanzhe Wang, Jiayuan Shen, Gongyu Liu, Yihang Han, Yaozu Wu, Jinfeng Deng, Hang Dong, Pengfei Zhang, Hekang Li, Zhen Wang, Chao Song, Chen Cheng, Rubem Mondaini, Qiujiang Guo, Biao Huang, H. Wang</div>
                <div class="summary">
                摘要：周期性驱动的量子多体系统表现出各种奇异的非平衡现象，并为量子应用提供了一条有前景的途径。稳定和利用这些高度纠缠物态的基本挑战是系统通过吸收驱动能量而加热。在这里，我们提出并展示了一种无杂乱机制，称为Fock空间预热化(FSP)，以抑制加热。该机制将Fock空间网络划分为线性数量稀疏的子网络，从而延长了初始状态在高能密度下的热化时间尺度。使用72个超导量子比特，我们观察到基于FSP的时间结晶顺序，该顺序在120个周期内对通用初始Fock态保持不变。通过测量位解关联数，识别出约束保存的域墙(DW)数量的潜在动力学约束。此外，我们通过改变系统大小，对DW和Fock空间动力学进行了有限尺度分析，揭示了FSP热化跨越与尺寸无关的区域，并将动力学行为与Floquet单元矩阵的本征结构联系起来。我们的工作确立了FSP作为打破遍历性的一种鲁棒机制，为探索新型非平衡量子物质及其应用铺平了道路。
                </div>
                <a href="https://arxiv.org/abs/2510.24059" class="link">https://arxiv.org/abs/2510.24059</a>
                <div class="comment-section">
                    <h3>评论</h3>
                    <input type="text" class="comment-input" id="comment-input-7" placeholder="输入评论">
                    <button class="comment-button" onclick="addComment(7)">提交评论</button>
                    <ul class="comment-list" id="comment-list-7"></ul>
                </div>
                </div>
                
                <div class="literature-item" style="background-color: #fff;">
                <h2>Exploring the Fidelity of Flux Qubit Measurement in Different Bases via Quantum Flux Parametron</h2>
                <div class="authors">Yanjun Ji, Susanna Kirchhoff, Frank K. Wilhelm</div>
                <div class="summary">
                摘要：高保真量子比特读出是实用量子计算系统的基本要求。在这项工作中，我们研究通过量子通量参数子介导的读出方案来增强磁通量量子比特的测量保真度的方法。通过理论建模和数值模拟，我们分析了不同测量基准对单量子比特和耦合两量子比特系统中保真度的影响。在单量子比特系统中，我们证明能量基准在实现更高保真度方面始终优于通量基准。在耦合两量子比特系统中，我们探索了两种测量模型：顺序和同时测量，两者都旨在读出单个目标量子比特。我们的结果表明，最高保真度可以通过以更长时间的着装基础上进行顺序测量，或以较短时间的裸基准上进行同时测量来实现。重要的是，与同时测量方法相比，顺序测量模型始终提供更稳健且更高保真的读出结果。这些发现量化了可实现的保真度，并为优化新兴量子计算架构中的测量协议提供了宝贵的指导。
                </div>
                <a href="https://arxiv.org/abs/2510.24082" class="link">https://arxiv.org/abs/2510.24082</a>
                <div class="comment-section">
                    <h3>评论</h3>
                    <input type="text" class="comment-input" id="comment-input-8" placeholder="输入评论">
                    <button class="comment-button" onclick="addComment(8)">提交评论</button>
                    <ul class="comment-list" id="comment-list-8"></ul>
                </div>
                </div>
                
                <div class="literature-item" style="background-color: #fff;">
                <h2>Matrix product state approach to lossy boson sampling and noisy IQP sampling</h2>
                <div class="authors">Sojeong Park, Changhun Oh</div>
                <div class="summary">
                摘要：抽样问题已成为展示量子优势的核心领域，尤其是在有噪声的中间规模量子设备上。然而，物理噪声会从根本上改变计算复杂性，使得许多问题可以用经典方法处理。受最近基于矩阵积态（MPS）的经典模拟高斯玻色子抽样的成功（Oh等人，2024年）启发，我们将该框架扩展到其他有噪声量子抽样模型的经典可模拟性研究中。我们开发了基于MPS的经典算法，用于损失玻色子抽样和有噪声即时量子多项式时间（IQP）抽样，这些算法通过键结维度保留了MPS方法的可调准度特性。我们的方法构建了纯态分解，对于输入状态在经过电路演化后仍保持弱纠缠的组件，从而提供了一种系统探索量子难以解决与经典可模拟区域之间边界的手段。对于玻色子抽样，我们分析了单光子、Fock态和猫态输入，表明经典可模拟性在传输速率按O(1/√N)比例缩放时出现，达到已知的量子优势边界，并提供了一种可调节和可扩展的方法。除了再现先前的阈值外，我们的算法在准确性与效率之间的权衡上提供了显著改进。它进一步将基于MPS的模拟应用扩展到更广泛类别的有噪声量子抽样模型，包括IQP电路。
                </div>
                <a href="https://arxiv.org/abs/2510.24137" class="link">https://arxiv.org/abs/2510.24137</a>
                <div class="comment-section">
                    <h3>评论</h3>
                    <input type="text" class="comment-input" id="comment-input-9" placeholder="输入评论">
                    <button class="comment-button" onclick="addComment(9)">提交评论</button>
                    <ul class="comment-list" id="comment-list-9"></ul>
                </div>
                </div>
                
                <div class="literature-item" style="background-color: #fff;">
                <h2>An exact Error Threshold of Surface Code under Correlated Nearest-Neighbor Errors: A Statistical Mechanical Analysis</h2>
                <div class="authors">SiYing Wang, ZhiXin Xia, Yue Yan, Xiang-Bin Wang</div>
                <div class="summary">
                摘要：表面代码是容错量子计算的一个有前途的候选者，因为它具有高误差阈值，并且可以通过最近邻交互进行实验访问。然而，当前的精确表面代码阈值分析基于独立且同分布（i.i.d.）错误的假设。虽然有关相关错误阈值的数值研究存在，但它们只是下限，而非准确值，这为更高的误差提供了潜力。在此，我们建立了一个误差边缘地图，它允许将量子误差纠正映射到一个方形-八角随机键合金模型。然后我们在结合独立单比特错误和最近邻数据比特相关错误的现实噪声模型下，提出精确阈值。我们的方法适用于任何最近邻相关错误与i.i.d.错误的比例。我们研究了表面代码的误差纠正阈值，并提出了分析约束，给出了误差阈值的准确值。这意味着我们的误差阈值既是上限又是可达到的，因此一方面，现有的数值阈值都可以提高到我们的阈值，另一方面，我们的阈值在 principle 上是最高的可实现值。
                </div>
                <a href="https://arxiv.org/abs/2510.24181" class="link">https://arxiv.org/abs/2510.24181</a>
                <div class="comment-section">
                    <h3>评论</h3>
                    <input type="text" class="comment-input" id="comment-input-10" placeholder="输入评论">
                    <button class="comment-button" onclick="addComment(10)">提交评论</button>
                    <ul class="comment-list" id="comment-list-10"></ul>
                </div>
                </div>
                
                <div class="literature-item" style="background-color: #fff;">
                <h2>Jacobi-Anger Density Estimation for Energy Distribution of Quantum States</h2>
                <div class="authors">Kyeongan Park, Gwonhak Lee, Minhyeok Kang, Youngjun Park, Joonsuk Huh</div>
                <div class="summary">
                摘要：在量子计算中，准确估计分子的基态能需要了解量子态的能量分布。直接获取这一分布需要对哈密顿量进行完全对角化，但这种方法对于大规模系统来说计算成本过高。更实用的策略是从有限数量的哈密顿量时刻近似该分布。然而，从仅有的几个时刻重建精确的分布仍然是一个巨大的挑战。在这项工作中，我们引入了雅可比-安格尔密度估计（JADE），一种非参数化、受量子启发的方法，旨在克服这一困难。JADE通过使用雅可比-安格尔展开式从有限数量的时刻重建特征函数，然后通过逆傅里叶变换估计潜在分布。我们展示了JADE能够准确恢复分子系统中量子态的能量分布。不仅限于量子化学，我们还表明JADE广泛适用于各种科学和工程领域中复杂概率密度函数的估计。我们的结果强调了JADE作为一个功能强大且多样化的实用量子系统工具的潜力，可能显著提高基态能估计和相关应用。
                </div>
                <a href="https://arxiv.org/abs/2510.24316" class="link">https://arxiv.org/abs/2510.24316</a>
                <div class="comment-section">
                    <h3>评论</h3>
                    <input type="text" class="comment-input" id="comment-input-11" placeholder="输入评论">
                    <button class="comment-button" onclick="addComment(11)">提交评论</button>
                    <ul class="comment-list" id="comment-list-11"></ul>
                </div>
                </div>
                
                <div class="literature-item" style="background-color: #fff;">
                <h2>Quantum Combinatorial Reasoning for Large Language Models</h2>
                <div class="authors">Carlos Flores-Garrigos, Gaurav Dev, Michael Falkenthal, Alejandro Gomez Cadavid, Anton Simen, Shubham Kumar, Enrique Solano, Narendra N. Hegade</div>
                <div class="summary">
                摘要：我们设计并实施了一个针对大型语言模型的量子组合推理框架（QCR-LLM），该框架在混合工作流中整合了一台真正的量子计算机。QCR-LLM将推理聚合重新表述为一种高阶无约束二进制优化问题（HUBO）。在这个意义上，推理片段被表示为二进制变量，它们之间的相互作用编码了统计相关性、逻辑连贯性和语义冗余。我们通过模拟退火等经典方法以及在IBM超导数字量子处理器上执行偏置场数字反对角线量子优化器（BF-DCQO）来解决所得到的高阶优化问题。在BIG-Bench Extra Hard（BBEH）基准测试中，实验表明，我们的QCR-LLM在多个大型语言模型（LLM）骨架上始终提高了推理精度，超过了o3-high和DeepSeek R1等专为推理设计的系统，最多提高了$+9\,$pp。尽管需要在每个查询中使用多次推理样本，但我们的QCR-LLM仍然比o3-high节能约五倍，这得益于其GPT-4o骨架的低每令牌能耗。这些结果构成了量子辅助推理的首个实验证据，表明混合量子-经典优化可以有效提高大型语言模型中推理连贯性、可解释性和可持续性。我们为量子智能的出现开辟了道路，其中更困难的问题提示需要在量子优势水平上的量子优化器。
                </div>
                <a href="https://arxiv.org/abs/2510.24509" class="link">https://arxiv.org/abs/2510.24509</a>
                <div class="comment-section">
                    <h3>评论</h3>
                    <input type="text" class="comment-input" id="comment-input-12" placeholder="输入评论">
                    <button class="comment-button" onclick="addComment(12)">提交评论</button>
                    <ul class="comment-list" id="comment-list-12"></ul>
                </div>
                </div>
                
                <div class="literature-item" style="background-color: #fff;">
                <h2>Efficient magic state cultivation with lattice surgery</h2>
                <div class="authors">Yutaka Hirano, Riki Toshio, Tomohiro Itogawa, Keisuke Fujii</div>
                <div class="summary">
                摘要：魔法态馏分在容错量子计算中起着至关重要的作用，并且是目前的一个主要瓶颈。与传统的逻辑层级馏分不同，物理层级馏分通过能够直接用物理门实现，提供了显著的开销减少。在物理层级馏分协议中，魔法态培育是一个兼容平方网格连接性的最先进协议，并能生成高保真度的魔法态。然而，它依赖于复杂的接枝码，从而引发大量的时空开销，并使实际实现更加复杂。在本研究中，我们提出了一种有效的、基于培育的协议，该协议兼容平方网格连接性。通过避免使用接枝码，我们减少了空间开销，并通过采用码展开和启用早期拒绝机制，进一步降低了平均时空开销。数值模拟表明，在颜色码距离为3且物理错误概率为10^{-3}的情况下，我们的协议实现的魔法态逻辑错误概率（≈ 3 × 10^{-6}）与魔法态培育的结果相当，同时所需时空开销约为其一半。本研究提供了一种高效且简单的馏分协议，适用于超大规模量子计算和早期容错设
                </div>
                <a href="https://arxiv.org/abs/2510.24615" class="link">https://arxiv.org/abs/2510.24615</a>
                <div class="comment-section">
                    <h3>评论</h3>
                    <input type="text" class="comment-input" id="comment-input-13" placeholder="输入评论">
                    <button class="comment-button" onclick="addComment(13)">提交评论</button>
                    <ul class="comment-list" id="comment-list-13"></ul>
                </div>
                </div>
                
                <div class="literature-item" style="background-color: #fff;">
                <h2>Repulsively Bound Hadrons in a $\mathbb{Z}_2$ Lattice Gauge Theory</h2>
                <div class="authors">Sayak Guha Roy, Vaibhav Sharma, Kaidi Xu, Umberto Borla, Jad C. Halimeh, Kaden R. A. Hazzard</div>
                <div class="summary">
                摘要：A paradigmatic model, the $\mathbb{Z}_2$ lattice gauge theory exhibits confinement mediated by the gauge field that binds pairs of particles into mesons, drawing connections to quantum chromodynamics. In the absence of any additional attractive interactions between particles, mesons are not known to bind in this model. Here, we show that resonant pair-production terms give rise to an additional repulsive binding mechanism that forms a stable ``hadron'' bound state of two mesons. A high-energy state, the hadron is stabilized by being off-resonantly coupled to a continuum. We study the dynamical formation of this bound state starting from local excitations. We use matrix product state techniques based on the time-evolving block decimation algorithm to perform our numerical simulations and analyze the effect of model parameters on hadron formation. Furthermore, we derive an effective model that explains its formation. Our findings are amenable to experimental observation on modern quantum hardware from superconducting qubits to trapped ions.
                </div>
                <a href="https://arxiv.org/abs/2510.23618" class="link">https://arxiv.org/abs/2510.23618</a>
                <div class="comment-section">
                    <h3>评论</h3>
                    <input type="text" class="comment-input" id="comment-input-14" placeholder="输入评论">
                    <button class="comment-button" onclick="addComment(14)">提交评论</button>
                    <ul class="comment-list" id="comment-list-14"></ul>
                </div>
                </div>
                
                <div class="literature-item" style="background-color: #fff;">
                <h2>LEVITAS: Levitodynamics for Accurate Individual Particle Sensing in Space</h2>
                <div class="authors">Rafal Gajewski, Ravindra T Desai, James Bateman, Bengt Eliasson, Daniel K L Oi, Animesh Datta</div>
                <div class="summary">
                
                </div>
                <a href="https://arxiv.org/abs/2510.24524" class="link">https://arxiv.org/abs/2510.24524</a>
                <div class="comment-section">
                    <h3>评论</h3>
                    <input type="text" class="comment-input" id="comment-input-15" placeholder="输入评论">
                    <button class="comment-button" onclick="addComment(15)">提交评论</button>
                    <ul class="comment-list" id="comment-list-15"></ul>
                </div>
                </div>
                
                <div class="literature-item" style="background-color: #fff;">
                <h2>Improved QLDPC Surgery: Logical Measurements and Bridging Codes</h2>
                <div class="authors">Andrew W. Cross, Zhiyang He, Patrick J. Rall, Theodore J. Yoder</div>
                <div class="summary">
                摘要：In this paper, we introduce the gauge-fixed QLDPC surgery scheme, an improved logical measurement scheme based on the construction of Cohen et al. (Sci. Adv. 8, eabn1717). Our scheme leverages expansion properties of the Tanner graph to substantially reduce the space overhead of QLDPC surgery. In certain cases, we only require $\Theta(w)$ ancilla qubits to fault-tolerantly measure a weight $w$ logical operator. We provide rigorous analysis for the code distance and fault distance of our schemes, and present a modular decoding algorithm that achieves maximal fault-distance. We further introduce a bridge system to facilitate fault-tolerant joint measurements of logical operators. Augmented by this bridge construction, our scheme can be used to connect different families of QLDPC codes into one universal architecture.

Applying our toolbox, we show how to perform all logical Clifford gates on the [[144,12,12]] bivariate bicycle code. Our scheme adds 103 ancilla qubits into the connectivity graph, and one of the twelve logical qubits is used as an ancilla for gate synthesis. Logical measurements are combined with the automorphism gates studied by Bravyi et al. (Nature 627, 778-782) to implement 288 Pauli product measurements. We demonstrate the practicality of our scheme through circuit-level noise simulations, leveraging our proposed modular decoder that combines BPOSD with matching.
                </div>
                <a href="https://arxiv.org/abs/2407.18393" class="link">https://arxiv.org/abs/2407.18393</a>
                <div class="comment-section">
                    <h3>评论</h3>
                    <input type="text" class="comment-input" id="comment-input-16" placeholder="输入评论">
                    <button class="comment-button" onclick="addComment(16)">提交评论</button>
                    <ul class="comment-list" id="comment-list-16"></ul>
                </div>
                </div>
                
                <div class="literature-item" style="background-color: #fff;">
                <h2>Quantum-Trajectory-Inspired Lindbladian Simulation</h2>
                <div class="authors">Sirui Peng, Xiaoming Sun, Qi Zhao, Hongyi Zhou</div>
                <div class="summary">
                摘要：模拟开放量子系统的动力学在量子计算中具有重要意义，尽管应用广泛，但在计算上仍然具有挑战性。本文提出了两种用于模拟由Lindblatt算符描述的开放量子系统动力学的量子算法。我们引入了一种新的近似通道，受量子轨迹方法启发，为我们的算法提供了效率基础。第一个算法在门复杂度上与跳跃算符的数量无关，这是一个显著的效率提升。第二个算法实现了对演化时间和精度接近最优的依赖关系，并且引入了额外的O(m)因子，这比现有的O(m²)门基量子算法有显著改进。改进源于将新的近似通道与一种新颖的结构化线性单元组合方法相结合。在我们的两个算法中，对m的依赖关系降低显著提高了模拟实际耗散过程效率，这些过程通常由大量跳跃算符描述。
                </div>
                <a href="https://arxiv.org/abs/2408.10505" class="link">https://arxiv.org/abs/2408.10505</a>
                <div class="comment-section">
                    <h3>评论</h3>
                    <input type="text" class="comment-input" id="comment-input-17" placeholder="输入评论">
                    <button class="comment-button" onclick="addComment(17)">提交评论</button>
                    <ul class="comment-list" id="comment-list-17"></ul>
                </div>
                </div>
                
                <div class="literature-item" style="background-color: #fff;">
                <h2>Probing non-equilibrium topological order on a quantum processor</h2>
                <div class="authors">M. Will, T. A. Cochran, E. Rosenberg, B. Jobst, N. M Eassa, P. Roushan, M. Knap, A. Gammon-Smith, F. Pollmann</div>
                <div class="summary">
                摘要：非平衡相在多体系统中构成了量子物质的一个新范式——它们表现出动力学特性，这些特性可能被平衡热力学所禁止。在这些非平衡相中，周期驱动（Floquet）系统[1-5]由于其高度纠缠，通常难以用经典方法模拟。我们在超导量子比特阵列上实现了理论上提出的Floquet拓扑有序态[6]。我们成像了其弦状边界模式的特征动力学，并表征了其出现的任意自旋激发。设计一种干涉算法，使我们能够引入和测量散度顶点不变式，以探测系统规模高达58个量子比特时的任意子动力学转化。我们的工作证明了量子处理器可以提供对迄今大部分未探索的高纠缠非平衡物质相景观的关键见解。
                </div>
                <a href="https://arxiv.org/abs/2501.18461" class="link">https://arxiv.org/abs/2501.18461</a>
                <div class="comment-section">
                    <h3>评论</h3>
                    <input type="text" class="comment-input" id="comment-input-18" placeholder="输入评论">
                    <button class="comment-button" onclick="addComment(18)">提交评论</button>
                    <ul class="comment-list" id="comment-list-18"></ul>
                </div>
                </div>
                
                <div class="literature-item" style="background-color: #fff;">
                <h2>Direct Analysis of Zero-Noise Extrapolation: Polynomial Methods, Error Bounds, and Simultaneous Physical-Algorithmic Error Mitigation</h2>
                <div class="authors">Pegah Mohammadipour, Xiantao Li</div>
                <div class="summary">
                摘要：Zero-noise extrapolation (ZNE) 是一种广泛使用的量子误差缓解技术，其通过人为放大电路噪声，然后将结果外推到无噪声电路。Richardson 外推法是常见的 ZNE 方法，依赖于多项式插值。尽管其简单性，Richardson 外推法的高效实现面临多个挑战，包括由于噪声信道的非多项式行为导致的近似误差、过拟合以及指数放大的测量噪声。本文对这些挑战进行了全面分析，并提出了偏差和方差界限以量化近似误差。此外，对于任何精度 ε，我们的结果提供了所需样本复杂度的估计。我们进一步将分析扩展到基于多项式最小二乘法的外推方法，以减轻测量噪声并避免过拟合。最后，我们提出了一个策略，通过同时缩放时间步长和噪声水平来同时缓解 Trotter-Suzuki 算法中的电路和算法错误。该策略提供了一种实用工具以增强近期量子计算的可靠性。我们通过数值实验支持了我们的理论发现。
                </div>
                <a href="https://arxiv.org/abs/2502.20673" class="link">https://arxiv.org/abs/2502.20673</a>
                <div class="comment-section">
                    <h3>评论</h3>
                    <input type="text" class="comment-input" id="comment-input-19" placeholder="输入评论">
                    <button class="comment-button" onclick="addComment(19)">提交评论</button>
                    <ul class="comment-list" id="comment-list-19"></ul>
                </div>
                </div>
                
                <div class="literature-item" style="background-color: #fff;">
                <h2>Preparing Code States via Seed-Entangler-Enriched Sequential Quantum Circuits: Application to Tetra-Digit Topological Error-Correcting Codes</h2>
                <div class="authors">Yu-Tao Hu, Meng-Yuan Li, Peng Ye</div>
                <div class="summary">
                摘要：该研究提出了一种构造拓扑量子纠错码编码空间中长距离纠缠态的新框架，具有重要意
                </div>
                <a href="https://arxiv.org/abs/2503.05374" class="link">https://arxiv.org/abs/2503.05374</a>
                <div class="comment-section">
                    <h3>评论</h3>
                    <input type="text" class="comment-input" id="comment-input-20" placeholder="输入评论">
                    <button class="comment-button" onclick="addComment(20)">提交评论</button>
                    <ul class="comment-list" id="comment-list-20"></ul>
                </div>
                </div>
                
                <div class="literature-item" style="background-color: #fff;">
                <h2>Exponentially Decaying Quantum Simulation Error with Noisy Devices</h2>
                <div class="authors">Jue Xu, Chu Zhao, Junyu Fan, Qi Zhao</div>
                <div class="summary">
                摘要：This work investigates the potential of quantum simulation to achieve practical quantum advantage and explores how noise in current quantum hardware affects this goal. The study demonstrates that both physical errors and algorithmic errors in a single Trotter step decrease exponentially with circuit depth, supported by numerical results across various Hamiltonians, initial states, and noise channels. Additionally, the optimal number of Trotter steps and noise requirements are derived to ensure simulation accuracy. A phase diagram is plotted to illustrate accumulated error based on circuit depth and noise rate, providing insights into robust quantum simulation requirements. The improved error analysis significantly reduces resource consumption for fault-tolerant Trotter circuits, offering new perspectives on practical quantum advantage through quantum simulation.
                </div>
                <a href="https://arxiv.org/abs/2504.10247" class="link">https://arxiv.org/abs/2504.10247</a>
                <div class="comment-section">
                    <h3>评论</h3>
                    <input type="text" class="comment-input" id="comment-input-21" placeholder="输入评论">
                    <button class="comment-button" onclick="addComment(21)">提交评论</button>
                    <ul class="comment-list" id="comment-list-21"></ul>
                </div>
                </div>
                
                <div class="literature-item" style="background-color: #fff;">
                <h2>Sub-Terahertz Spin Relaxation Dynamics of Boron-Vacancy Centers in Hexagonal Boron Nitride</h2>
                <div class="authors">Abhishek Bharatbhai Solanki, Yueh-Chun Wu, Hamza Ather, Priyo Adhikary, Aravindh Shankar, Ian Gallagher, Xingyu Gao, Owen M. Matthiessen, Demid Sychev, Alexei Lagoutchev, Tongcang Li, Yong P. Chen, Vladimir M. Shalaev, Benjamin Lawrie, Pramey Upadhyaya</div>
                <div class="summary">
                摘要：基于自旋缺陷放松的量子传感器已成为检测微弱磁信号的强大工具，但它们的操作在很大程度上仍局限于低磁场和千兆赫频率。将此类传感器扩展到高场（> 0.3 T）和亚太赫兹领域，将能够实现对广泛电磁现象和科学应用的量子测度学，但这一举措面临挑战。我们在这里证明，二维六方氮化硼中带负电的硼空位（V_B^-）可以作为基于放松的量子传感器，其工作频率最高可达0.2太赫兹。它们在高场下的均匀自旋取向和持续自旋对比度，使得能够直接测量内在自旋放松现象，这在以往尚未探索过的温度和频率领域。我们还揭示了自旋放松行为的一个转折点：最初在低场下减小，但随着场强增加而上升，这与单声子诱导的共振噪声的出现相一致，而这种噪声在亚太赫兹频率下显得尤为重要。这些结果确立了V_B^-中心作为亚太赫兹和高场领域中多功能量子感测平台的地位
                </div>
                <a href="https://arxiv.org/abs/2507.16786" class="link">https://arxiv.org/abs/2507.16786</a>
                <div class="comment-section">
                    <h3>评论</h3>
                    <input type="text" class="comment-input" id="comment-input-22" placeholder="输入评论">
                    <button class="comment-button" onclick="addComment(22)">提交评论</button>
                    <ul class="comment-list" id="comment-list-22"></ul>
                </div>
                </div>
                
                <div class="literature-item" style="background-color: #fff;">
                <h2>Intrinsic Heralding and Optimal Decoders for Non-Abelian Topological Order</h2>
                <div class="authors">Dian Jing, Pablo Sala, Liang Jiang, Ruben Verresen</div>
                <div class="summary">
                摘要：拓扑顺序（TO）为存储和操作量子信息提供了自然平台。然而，其对噪声的稳定性研究仅系统地理解了阿贝尔拓扑顺序。在这项工作中，我们利用非阿贝尔任何子的非确定性融合来告知主动错误校正，并设计解码器，其中融合产物而不是标志量子比特来预示噪声。这种固有的预示增强了阈值，超越了阿贝尔对应物在单一非阿贝尔任何子类型占主导地位时的噪声。此外，我们使用贝叶斯推断获得了一个统计力学模型，用于具有完美测量的固定点非阿贝尔拓扑顺序，在任何噪声模型下都能得到最优阈值，这是条件于任何子综合征的测量。我们通过数字结果说明了这些适用于D4≅Z4 ⋊ Z2拓扑顺序的应用。特别地，对于非阿贝尔电荷噪声和完美综合征测量，我们发现有条件的最优阈值pc=0.218(1)，而固有预示的最小权重完美匹配（MWPM）解码器已经给出pc=0.20842(2)，超越了标准MWPM的pc=0.15860(1)。我们的工作强调了非阿贝尔特性如何增强稳定性，而不是减少它，并讨论了实现容错的潜在推广。
                </div>
                <a href="https://arxiv.org/abs/2507.23765" class="link">https://arxiv.org/abs/2507.23765</a>
                <div class="comment-section">
                    <h3>评论</h3>
                    <input type="text" class="comment-input" id="comment-input-23" placeholder="输入评论">
                    <button class="comment-button" onclick="addComment(23)">提交评论</button>
                    <ul class="comment-list" id="comment-list-23"></ul>
                </div>
                </div>
                
                <div class="literature-item" style="background-color: #fff;">
                <h2>Efficient Post-Selection for General Quantum LDPC Codes</h2>
                <div class="authors">Seok-Hyung Lee, Lucas English, Stephen D. Bartlett</div>
                <div class="summary">
                摘要：后选择策略通过丢弃低置信度的计算结果可以显著提高量子错误纠正的有效保真度，尽管这会降低接受率，这对于离线资源状态生成特别有用。以往的工作主要依赖于"逻辑间隙"指标和最小权重完美匹配解码器，但这种方法面临计算开销随逻辑量子比特数量呈指数级增长等基本限制，并且难以推广到表面码以外的任意码。我们开发了基于计算高效启发式置信度指标的后选择策略，这些指标利用聚类解码器中的错误簇统计（特别是聚合簇大小和对数似然比），适用于任意量子低密度奇偶校验码。通过对表面码、双变量自行车码和超图积码的广泛数值模拟，我们展示了逻辑错误率显著降低，例如在[[144, 12, 12]]双变量自行车码上应用我们的策略，在物理错误率为0.1%（0.3%）时，逻辑错误率降低约三个数量级，放弃率仅为1%（19%）。此外，我们将我们的方法与滑动窗口框架集成以实现实时解码，并做出了早期中电路放弃决策，从而消除了不必要的开销。值得注意的是，与原始策略相比，其性能匹配甚至超越，同时在轮数方面表现出有利的缩放。我们的方法为使用QLDPC码的容错量子计算中的高效后选择提供了实际基础。
                </div>
                <a href="https://arxiv.org/abs/2510.05795" class="link">https://arxiv.org/abs/2510.05795</a>
                <div class="comment-section">
                    <h3>评论</h3>
                    <input type="text" class="comment-input" id="comment-input-24" placeholder="输入评论">
                    <button class="comment-button" onclick="addComment(24)">提交评论</button>
                    <ul class="comment-list" id="comment-list-24"></ul>
                </div>
                </div>
                
                <div class="literature-item" style="background-color: #fff;">
                <h2>Approximate maximum likelihood decoding with $K$ minimum weight matchings</h2>
                <div class="authors">Mao Lin</div>
                <div class="summary">
                
                </div>
                <a href="https://arxiv.org/abs/2510.06531" class="link">https://arxiv.org/abs/2510.06531</a>
                <div class="comment-section">
                    <h3>评论</h3>
                    <input type="text" class="comment-input" id="comment-input-25" placeholder="输入评论">
                    <button class="comment-button" onclick="addComment(25)">提交评论</button>
                    <ul class="comment-list" id="comment-list-25"></ul>
                </div>
                </div>
                
                <div class="literature-item" style="background-color: #fff;">
                <h2>Application Scale Quantum Circuit Compilation with Controlled Error</h2>
                <div class="authors">Justin Kalloor, Lucas Kovalsky, Mathias Weiden, John Kubiatowicz, Ed Younis, Costin Iancu, Mohan Sarovar</div>
                <div class="summary">
                摘要：量子电路的编译和优化是执行量子计算机算法的关键部分。这些组件必须成功地平衡两种竞争性目标：最小化昂贵资源（如双量子位门或任意角度单量子位旋转）的数量，并最大限度地减少编译电路与理想目标单位矩阵之间的近似误差。我们开发了一种实际的工作流程来管理和优化这种权衡，能够在数百个量子位的规模上进行量子电路的编译和优化。我们的工作流程通过利用电路分区和电路集成平均的概念，可以处理大规模的电路，同时对电路输出误差提供严格保证。我们在几个基准算法电路上展示了我们的工作流程，这些电路作用于多达380个量子位，并表明它可以同时显著减少资源密集型门的数量并控制输出误差，提供了一种适用于近期和容错量子计算的实用且可扩展的策略。
                </div>
                <a href="https://arxiv.org/abs/2510.18000" class="link">https://arxiv.org/abs/2510.18000</a>
                <div class="comment-section">
                    <h3>评论</h3>
                    <input type="text" class="comment-input" id="comment-input-26" placeholder="输入评论">
                    <button class="comment-button" onclick="addComment(26)">提交评论</button>
                    <ul class="comment-list" id="comment-list-26"></ul>
                </div>
                </div>
                
                <div class="literature-item" style="background-color: #fff;">
                <h2>Miniaturized magnetic-field sensor based on nitrogen-vacancy centers</h2>
                <div class="authors">Stefan Johansson, Dennis Lönard, Isabel Cardoso Barbosa, Jonas Gutsche, Jonas Witzenrath, Artur Widera</div>
                <div class="summary">
                摘要：氮空位（NV）中心在钻石中是量子传感技术的理想候选者。我们这里展示了一种完全集成且机械稳固的光纤内窥镜传感器，传感器的尖端直径为1.25毫米。在其尖端，我们使用直接激光写入工艺在聚合物结构内固定了含有NV中心的钻石，其位置位于光纤芯的上方。此外，一种金属直接激光写入天线结构旁边的光纤facet，使得对NV中心自旋的微波操控效率很高。传感器在使用15微米大小的微钻石、微波功率为50毫瓦和光功率为2.15毫瓦的情况下，实现了布拉梅射噪声极限的磁场灵敏度5.9纳特斯拉每根赫兹。通过锁定技术，我们测量到了51.8纳特斯拉每根赫兹的灵敏度。此外，我们引入了一种双光纤概念，它结合直接激光写入结构，能够独立地引导激发光和荧光，从而降低了背景自发荧光。另外，在避免样品照明的情况下，控制激发光指向钻石的引导可能在生物组织等对光敏感的环境中实现操作。尽管演示的灵敏度是在单光纤配置下实现的，但双光纤方法提供了一种集成更小钻石的途径，其中自发荧光否则会限制性能。我们在超冷量子气体实验中使用的磁场中展示了矢量磁场测量的能力，这为需要高分辨率和高灵敏度的潜在领域开辟了道路。
                </div>
                <a href="https://arxiv.org/abs/2402.19372" class="link">https://arxiv.org/abs/2402.19372</a>
                <div class="comment-section">
                    <h3>评论</h3>
                    <input type="text" class="comment-input" id="comment-input-27" placeholder="输入评论">
                    <button class="comment-button" onclick="addComment(27)">提交评论</button>
                    <ul class="comment-list" id="comment-list-27"></ul>
                </div>
                </div>
                
                <div class="literature-item" style="background-color: #fff;">
                <h2>$\mathbb{Z}_2$ lattice gauge theories: fermionic gauging, transmutation, and Kramers-Wannier dualities</h2>
                <div class="authors">Lei Su</div>
                <div class="summary">
                摘要：我们通过插入Majorana费米子来推广$\mathbb{Z}_2$对称性的规范化，确立了波色和费米性晶格系统的并行对偶性。利用这种费米性规范化，我们构建了与横场Ising模型对偶的$\mathbb{Z}_2$ gauge理论的费米性类比，这些理论可以解释为Majorana稳定器码。我们展示了通过规范化自由费米系统的费米子奇偶性所获得的$\mathbb{Z}_2$ gauge理论与传统带有潜在非局部项的正方形晶格上的$\mathbb{Z}_2$ gauge理论之间的单元等价。这种等价通过一个线性深度的本地单元电路实现，通过方向依赖的任意子变换连接了波色和费米性的toric码。进一步，我们证明通过规范化费米子奇偶性获得的gauge理论等同于通过Jordan-Wigner变换得到的折叠Ising链。我们澄清了最近提出的Kramers-Wannier对偶性与沿空间覆盖路径规范$\mathbb{Z}_2$对称性所得结果之间的区别。我们的结果自然推广到更高维度的$\mathbb{Z}_2$晶格gauge理论，为波色和费米性的对偶性提供了一个统一框架，并为量子计算和模拟提供了新的见解。
                </div>
                <a href="https://arxiv.org/abs/2510.20893" class="link">https://arxiv.org/abs/2510.20893</a>
                <div class="comment-section">
                    <h3>评论</h3>
                    <input type="text" class="comment-input" id="comment-input-28" placeholder="输入评论">
                    <button class="comment-button" onclick="addComment(28)">提交评论</button>
                    <ul class="comment-list" id="comment-list-28"></ul>
                </div>
                </div>
                
        <script>
        function addComment(paperIndex) {
            const commentInput = document.getElementById(`comment-input-${paperIndex}`);
            const commentText = commentInput.value;
            if (commentText) {
                const commentList = document.getElementById(`comment-list-${paperIndex}`);
                const now = new Date();
                const timestamp = now.toLocaleString();
                const newComment = document.createElement('li');
                newComment.textContent = `${timestamp}: ${commentText}`;
                commentList.appendChild(newComment);
                // 保存评论到本地存储
                let comments = JSON.parse(localStorage.getItem(`comments-${paperIndex}`)) || [];
                comments.push(`${timestamp}: ${commentText}`);
                localStorage.setItem(`comments-${paperIndex}`, JSON.stringify(comments));
                commentInput.value = '';
            }
        }
        
        // 页面加载时显示本地存储的评论
        window.onload = function () {
            const comments0 = JSON.parse(localStorage.getItem(`comments-0`)) || []; const commentList0 = document.getElementById(`comment-list-0`); comments0.forEach(comment => { const newComment = document.createElement('li'); newComment.textContent = comment; commentList0.appendChild(newComment); });const comments1 = JSON.parse(localStorage.getItem(`comments-1`)) || []; const commentList1 = document.getElementById(`comment-list-1`); comments1.forEach(comment => { const newComment = document.createElement('li'); newComment.textContent = comment; commentList1.appendChild(newComment); });const comments2 = JSON.parse(localStorage.getItem(`comments-2`)) || []; const commentList2 = document.getElementById(`comment-list-2`); comments2.forEach(comment => { const newComment = document.createElement('li'); newComment.textContent = comment; commentList2.appendChild(newComment); });const comments3 = JSON.parse(localStorage.getItem(`comments-3`)) || []; const commentList3 = document.getElementById(`comment-list-3`); comments3.forEach(comment => { const newComment = document.createElement('li'); newComment.textContent = comment; commentList3.appendChild(newComment); });const comments4 = JSON.parse(localStorage.getItem(`comments-4`)) || []; const commentList4 = document.getElementById(`comment-list-4`); comments4.forEach(comment => { const newComment = document.createElement('li'); newComment.textContent = comment; commentList4.appendChild(newComment); });const comments5 = JSON.parse(localStorage.getItem(`comments-5`)) || []; const commentList5 = document.getElementById(`comment-list-5`); comments5.forEach(comment => { const newComment = document.createElement('li'); newComment.textContent = comment; commentList5.appendChild(newComment); });const comments6 = JSON.parse(localStorage.getItem(`comments-6`)) || []; const commentList6 = document.getElementById(`comment-list-6`); comments6.forEach(comment => { const newComment = document.createElement('li'); newComment.textContent = comment; commentList6.appendChild(newComment); });const comments7 = JSON.parse(localStorage.getItem(`comments-7`)) || []; const commentList7 = document.getElementById(`comment-list-7`); comments7.forEach(comment => { const newComment = document.createElement('li'); newComment.textContent = comment; commentList7.appendChild(newComment); });const comments8 = JSON.parse(localStorage.getItem(`comments-8`)) || []; const commentList8 = document.getElementById(`comment-list-8`); comments8.forEach(comment => { const newComment = document.createElement('li'); newComment.textContent = comment; commentList8.appendChild(newComment); });const comments9 = JSON.parse(localStorage.getItem(`comments-9`)) || []; const commentList9 = document.getElementById(`comment-list-9`); comments9.forEach(comment => { const newComment = document.createElement('li'); newComment.textContent = comment; commentList9.appendChild(newComment); });const comments10 = JSON.parse(localStorage.getItem(`comments-10`)) || []; const commentList10 = document.getElementById(`comment-list-10`); comments10.forEach(comment => { const newComment = document.createElement('li'); newComment.textContent = comment; commentList10.appendChild(newComment); });const comments11 = JSON.parse(localStorage.getItem(`comments-11`)) || []; const commentList11 = document.getElementById(`comment-list-11`); comments11.forEach(comment => { const newComment = document.createElement('li'); newComment.textContent = comment; commentList11.appendChild(newComment); });const comments12 = JSON.parse(localStorage.getItem(`comments-12`)) || []; const commentList12 = document.getElementById(`comment-list-12`); comments12.forEach(comment => { const newComment = document.createElement('li'); newComment.textContent = comment; commentList12.appendChild(newComment); });const comments13 = JSON.parse(localStorage.getItem(`comments-13`)) || []; const commentList13 = document.getElementById(`comment-list-13`); comments13.forEach(comment => { const newComment = document.createElement('li'); newComment.textContent = comment; commentList13.appendChild(newComment); });const comments14 = JSON.parse(localStorage.getItem(`comments-14`)) || []; const commentList14 = document.getElementById(`comment-list-14`); comments14.forEach(comment => { const newComment = document.createElement('li'); newComment.textContent = comment; commentList14.appendChild(newComment); });const comments15 = JSON.parse(localStorage.getItem(`comments-15`)) || []; const commentList15 = document.getElementById(`comment-list-15`); comments15.forEach(comment => { const newComment = document.createElement('li'); newComment.textContent = comment; commentList15.appendChild(newComment); });const comments16 = JSON.parse(localStorage.getItem(`comments-16`)) || []; const commentList16 = document.getElementById(`comment-list-16`); comments16.forEach(comment => { const newComment = document.createElement('li'); newComment.textContent = comment; commentList16.appendChild(newComment); });const comments17 = JSON.parse(localStorage.getItem(`comments-17`)) || []; const commentList17 = document.getElementById(`comment-list-17`); comments17.forEach(comment => { const newComment = document.createElement('li'); newComment.textContent = comment; commentList17.appendChild(newComment); });const comments18 = JSON.parse(localStorage.getItem(`comments-18`)) || []; const commentList18 = document.getElementById(`comment-list-18`); comments18.forEach(comment => { const newComment = document.createElement('li'); newComment.textContent = comment; commentList18.appendChild(newComment); });const comments19 = JSON.parse(localStorage.getItem(`comments-19`)) || []; const commentList19 = document.getElementById(`comment-list-19`); comments19.forEach(comment => { const newComment = document.createElement('li'); newComment.textContent = comment; commentList19.appendChild(newComment); });const comments20 = JSON.parse(localStorage.getItem(`comments-20`)) || []; const commentList20 = document.getElementById(`comment-list-20`); comments20.forEach(comment => { const newComment = document.createElement('li'); newComment.textContent = comment; commentList20.appendChild(newComment); });const comments21 = JSON.parse(localStorage.getItem(`comments-21`)) || []; const commentList21 = document.getElementById(`comment-list-21`); comments21.forEach(comment => { const newComment = document.createElement('li'); newComment.textContent = comment; commentList21.appendChild(newComment); });const comments22 = JSON.parse(localStorage.getItem(`comments-22`)) || []; const commentList22 = document.getElementById(`comment-list-22`); comments22.forEach(comment => { const newComment = document.createElement('li'); newComment.textContent = comment; commentList22.appendChild(newComment); });const comments23 = JSON.parse(localStorage.getItem(`comments-23`)) || []; const commentList23 = document.getElementById(`comment-list-23`); comments23.forEach(comment => { const newComment = document.createElement('li'); newComment.textContent = comment; commentList23.appendChild(newComment); });const comments24 = JSON.parse(localStorage.getItem(`comments-24`)) || []; const commentList24 = document.getElementById(`comment-list-24`); comments24.forEach(comment => { const newComment = document.createElement('li'); newComment.textContent = comment; commentList24.appendChild(newComment); });const comments25 = JSON.parse(localStorage.getItem(`comments-25`)) || []; const commentList25 = document.getElementById(`comment-list-25`); comments25.forEach(comment => { const newComment = document.createElement('li'); newComment.textContent = comment; commentList25.appendChild(newComment); });const comments26 = JSON.parse(localStorage.getItem(`comments-26`)) || []; const commentList26 = document.getElementById(`comment-list-26`); comments26.forEach(comment => { const newComment = document.createElement('li'); newComment.textContent = comment; commentList26.appendChild(newComment); });const comments27 = JSON.parse(localStorage.getItem(`comments-27`)) || []; const commentList27 = document.getElementById(`comment-list-27`); comments27.forEach(comment => { const newComment = document.createElement('li'); newComment.textContent = comment; commentList27.appendChild(newComment); });const comments28 = JSON.parse(localStorage.getItem(`comments-28`)) || []; const commentList28 = document.getElementById(`comment-list-28`); comments28.forEach(comment => { const newComment = document.createElement('li'); newComment.textContent = comment; commentList28.appendChild(newComment); });
        };
        </script>
        </body>
        </html>
        