
        <!DOCTYPE html>
        <html lang="en">
        <head>
        <meta charset="UTF-8">
        <title>2026-01-16 Arxiv papers related with quantum computing overview</title>
        <style>
        
        body {
            font-family: Arial, sans-serif;
            line-height: 1.6;
            margin: 40px;
            background-color: #f5f5f5;
        }
        .literature-item {
            background-color: white;
            padding: 20px;
            margin-bottom: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }
        h2 {
            color: #333;
            font-size: 24px;
            margin-top: 0;
            padding-bottom: 10px;
            border-bottom: 3px solid #eee;
        }
        .authors {
            color: #666;
            font-style: italic;
            margin-bottom: 15px;
        }
        .summary {
            color: #444;
            text-align: justify;
        }
        .link {
            display: block;
            margin-top: 10px;
            font-size: 14px;
            color: #337ab7;
            text-decoration: none;
        }
        .comment-section {
            margin-top: 10px;
        }
        .comment-input {
            width: 80%;
            padding: 5px;
            margin-right: 5px;
        }
        .comment-button {
            padding: 5px 10px;
        }
        .comment-list {
            list-style-type: none;
            padding: 0;
            margin-top: 5px;
        }
        .comment-list li {
            border: 1px solid #eee;
            padding: 5px;
            margin-bottom: 3px;
        }
        
        </style>
        </head>
        <body>
        <h1>2026-01-16 Arxiv papers related with quantum computing overview</h1>
        
        <h1>Keywords: ['superconducting qubit', 'quantum error correction', 'superconducting circuit', 'surface code', 'transmon', 'quantum parity detection', 'quasiparticle', 'quantum sensor', 'charge parity']</h1>
        

                <div class="literature-item" style="background-color: #fff;">
                <h2>Background cancellation for frequency-selective quantum sensing</h2>
                <div class="authors">Ricard Puig, Nathan Constantinides, Bharath Hebbe Madhusudhana, Daniel Bowring, C. Huerta Alderete, Andrew T. Sornborger</div>
                <div class="summary">
                摘要：在量子传感中，检测弱时间依赖信号，特别是那些作为特定频率扰动出现在背景场上的信号，是一项关键挑战。传统方法通常需要对量子传感器进行复杂的动态控制，并进行大量的经典后处理。我们提出了一种利用时间独立相互作用和纠缠来实现被动、可调谐且有阈值的频率滤波器的量子传感器。通过将频率选择性和阈值行为直接编码到动态中，该传感器仅对选择的目标频率响应，其幅度超过阈值。这一方法避免了复杂的控制方案，并减少了后处理开销。
                </div>
                <a href="https://arxiv.org/abs/2601.09792" class="link">https://arxiv.org/abs/2601.09792</a>
                <div class="comment-section">
                    <h3>评论</h3>
                    <input type="text" class="comment-input" id="comment-input-0" placeholder="输入评论">
                    <button class="comment-button" onclick="addComment(0)">提交评论</button>
                    <ul class="comment-list" id="comment-list-0"></ul>
                </div>
                </div>
                
                <div class="literature-item" style="background-color: #fff;">
                <h2>Time-Dynamic Circuits for Fault-Tolerant Shift Automorphisms in Quantum LDPC Codes</h2>
                <div class="authors">Younghun Kim, Spiro Gicev, Martin Sevior, Muhammad Usman</div>
                <div class="summary">
                摘要：量子低密度奇偶校验（qLDPC）代码已成为实现低开销逻辑量子存储记忆的有前途的方法。最近的理论发展将转移自动映射确立为qLDPC代码完成通用逻辑门集的基本构建块。然而，现有的基于SWAP的转移自动映射导致逻辑错误率比容错闲置操作高几个数量级。本工作通过动态调整综合征测量电路来实现转移自动映射，而无需降低电路距离。在扭曲和未扭曲的广义环面码上进行了benchmark，包括gross代码家族。在电路噪声模型（SI1000）下，我们的时间动态电路在转移自动映射上的性能与闲置操作相当。具体而言，在物理错误率为10^{-3}时，动态电路在gross代码上使用BP-OSD解码器时，将逻辑错误率降低了一个数量级以上，相较于SWAP方案。此外，本工作可为综合征提取电路的替代设计提供路径，如漏泄消除协议，使动态电路得以扩展应用，从表面码到qLDPC代码。 
                </div>
                <a href="https://arxiv.org/abs/2601.09911" class="link">https://arxiv.org/abs/2601.09911</a>
                <div class="comment-section">
                    <h3>评论</h3>
                    <input type="text" class="comment-input" id="comment-input-1" placeholder="输入评论">
                    <button class="comment-button" onclick="addComment(1)">提交评论</button>
                    <ul class="comment-list" id="comment-list-1"></ul>
                </div>
                </div>
                
                <div class="literature-item" style="background-color: #fff;">
                <h2>Learning to Decode in Parallel: Self-Coordinating Neural Network for Real-Time Quantum Error Correction</h2>
                <div class="authors">Kai Zhang, Zhengzhong Yi, Shaojun Guo, Linghang Kong, Situ Wang, Xiaoyu Zhan, Tan He, Weiping Lin, Tao Jiang, Dongxin Gao, Yiming Zhang, Fangming Liu, Fang Zhang, Zhengfeng Ji, Fusheng Chen, Jianxin Chen</div>
                <div class="summary">
                摘要：快速且可靠的解码器是实现容错量子计算（FTQC）的关键组件。像AlphaQubit这样的神经网络解码器显示出潜力，准确率超过传统的人类设计解码算法。然而，现有的神经网络解码器缺乏并行性，无法实时解码超导逻辑量子比特生成的综合征流。此外，将AlphaQubit集成到基于滑动窗口的并行解码方案中存在非平凡挑战：AlphaQubit仅训练为输出一个对应整个存储实验全局逻辑更正的一位，而不是可以轻松集成的局部物理更正。我们通过训练专门用于并行窗口解码的基于Transformer的循环神经网络来解决这个问题。虽然它仍然输出一位，但我们从一致的局部更正集中引导训练标签，并同时在各种类型的解码窗口上进行训练。这使得网络能够协调邻近窗口，实现对任意长度存储实验的高精度并行解码。结果，我们克服了先前阻碍AlphaQubit型解码器在FTQC中使用的吞吐量瓶颈。我们的工作展示了第一个可扩展、基于神经网络的并行解码框架，同时实现SOTA精度和实时量子纠错所需的严格吞吐量。使用端到端实验工作流，我们在距离最长为7的表面代码上对Zuchongzhi 3.2超导量子处理器上的解码器进行基准测试，展示了其优越的精度。此外，我们证明，使用我们的方法，单个TPU v6e能够在每轮解码时间不超过1微秒的情况下解码距离最长为25的表面代码。
                </div>
                <a href="https://arxiv.org/abs/2601.09921" class="link">https://arxiv.org/abs/2601.09921</a>
                <div class="comment-section">
                    <h3>评论</h3>
                    <input type="text" class="comment-input" id="comment-input-2" placeholder="输入评论">
                    <button class="comment-button" onclick="addComment(2)">提交评论</button>
                    <ul class="comment-list" id="comment-list-2"></ul>
                </div>
                </div>
                
                <div class="literature-item" style="background-color: #fff;">
                <h2>Pseudomode approach to Fano effect in dissipative cavity quantum electrodynamics</h2>
                <div class="authors">Kazuki Kobayashi, Tatsuro Yuge</div>
                <div class="summary">
                摘要：我们研究了耗散型腔量子电动力学中的Fano效应，该效应源于发射器的直接辐射与通过腔模式介导的辐射之间的干涉。从一个与结构化储ervoir耦合的两级系统开始，我们展示了一种之前在Born-Markov近似内推导出的量子.master方程可以通过引入单个辅助模式的伪模态方法重新推导。我们识别了系统-环境相互作用的相应谱函数，并证明它由一个常数和一个非洛伦兹贡献组成，形成Fano-profile。我们表明常数项对于获得Lindblad.master方程至关重要，并直接与与此Fano干涉相关的速率有关。此外，通过在包括显式腔模式的common-environment设定中应用Fano对角化，我们独立推导出相同的谱函数，在最强干涉区。我们的结果为描述单模腔QED系统中的Fano效应建立了一个统一框架，并阐明了其编码在谱函数中的非Markov起源。
                </div>
                <a href="https://arxiv.org/abs/2601.10087" class="link">https://arxiv.org/abs/2601.10087</a>
                <div class="comment-section">
                    <h3>评论</h3>
                    <input type="text" class="comment-input" id="comment-input-3" placeholder="输入评论">
                    <button class="comment-button" onclick="addComment(3)">提交评论</button>
                    <ul class="comment-list" id="comment-list-3"></ul>
                </div>
                </div>
                
                <div class="literature-item" style="background-color: #fff;">
                <h2>Classical simulation of a quantum circuit with noisy magic inputs</h2>
                <div class="authors">Jiwon Heo, Sojeong Park, Changhun Oh</div>
                <div class="summary">
                摘要：Magic states是通用量子计算所必需的，并且被广泛认为是量子优势的关键来源，但在现实设备中，它们不可避免地会受到噪声的影响。在这项研究中，我们表征了注入的魔术资源中的噪声如何改变量子电路的经典模拟性，以及噪声何时会导致从无法高效经典模拟到能够高效经典模拟的过渡。我们采用了一种资源为中心的噪声模型，其中只有注入的魔法组件是有噪声的，而基线状态、操作和测量属于一个可以高效模拟的家族。在这种设置下，我们开发了一个具有控制误差的近似经典采样算法，并证明了在特定依赖噪声的条件下，算法可以在多项式时间内运行。我们的框架适用于基线为Clifford的量子比特电路和基线为匹配门的fermionic电路，涵盖诸如去相位干扰和粒子损失等代表性噪声通道。我们通过对模拟成本进行数值估计来补充分析，提供具体的阈值和实际相关参数范围内的运行时间缩放。
                </div>
                <a href="https://arxiv.org/abs/2601.10111" class="link">https://arxiv.org/abs/2601.10111</a>
                <div class="comment-section">
                    <h3>评论</h3>
                    <input type="text" class="comment-input" id="comment-input-4" placeholder="输入评论">
                    <button class="comment-button" onclick="addComment(4)">提交评论</button>
                    <ul class="comment-list" id="comment-list-4"></ul>
                </div>
                </div>
                
                <div class="literature-item" style="background-color: #fff;">
                <h2>Bridging Superconducting and Neutral-Atom Platforms for Efficient Fault-Tolerant Quantum Architectures</h2>
                <div class="authors">Xiang Fang, Jixuan Ruan, Sharanya Prabhu, Ang Li, Travis Humble, Dean Tullsen, Yufei Ding</div>
                <div class="summary">
                摘要：The transition to the fault-tolerant era exposes the limitations of homogeneous quantum systems, where no single qubit modality simultaneously offers optimal operation speed, connectivity, and scalability. In this work, we propose a strategic approach to Heterogeneous Quantum Architectures (HQA) that synthesizes the distinct advantages of the superconducting (SC) and neutral atom (NA) platforms. We explore two architectural role assignment strategies based on hardware characteristics: (1) We offload the latency-critical Magic State Factory (MSF) to fast SC devices while performing computation on scalable NA arrays, a design we term MagicAcc, which effectively mitigates the resource-preparation bottleneck. (2) We explore a Memory-Compute Separation (MCSep) paradigm that utilizes NA arrays for high-density qLDPC memory storage and SC devices for fast surface-code processing. Our evaluation, based on a comprehensive end-to-end cost model, demonstrates that principled heterogeneity yields significant performance gains. Specifically, our designs achieve $752\times$ speedup over NA-only baselines on average and reduce the physical qubit footprint by over $10\times$ compared to SC-only systems. These results chart a clear pathway for leveraging cross-modality interconnects to optimize the space-time efficiency of future fault-tolerant quantum computers.
                </div>
                <a href="https://arxiv.org/abs/2601.10144" class="link">https://arxiv.org/abs/2601.10144</a>
                <div class="comment-section">
                    <h3>评论</h3>
                    <input type="text" class="comment-input" id="comment-input-5" placeholder="输入评论">
                    <button class="comment-button" onclick="addComment(5)">提交评论</button>
                    <ul class="comment-list" id="comment-list-5"></ul>
                </div>
                </div>
                
                <div class="literature-item" style="background-color: #fff;">
                <h2>Computing Statistical Properties of Velocity Fields on Current Quantum Hardware</h2>
                <div class="authors">Miriam Goldack, Yosi Atia, Ori Alberton, Karl Jansen</div>
                <div class="summary">
                摘要：量子算法在计算流体动力学（CFD）中受到关注，因为它们具有有利的缩放特性，将物理场编码到量子概率幅度中可以用n个量子位表示2^n个空间点。在量子CFD中的一个关键挑战是高效读取仿真结果，这一主题在文献中得到了有限的关注。本工作提出了一种方法，可以直接从参数化答案电路中提取空间速度场的统计性质，例如中心矩和结构函数，而无需进行完整的量子状态断幺。作为概念证明，我们在一维速度场上实现了我们的方法，使用4个量子位编码16个空间点，并分析了正弦波信号和Burgers方程演化的四个快照。使用Qedma的错误缓解软件QESEM，我们展示了这种计算在当前的量子设备上具有高精度，特别是IBMQ的Heron2系统ibm_fez。
                </div>
                <a href="https://arxiv.org/abs/2601.10166" class="link">https://arxiv.org/abs/2601.10166</a>
                <div class="comment-section">
                    <h3>评论</h3>
                    <input type="text" class="comment-input" id="comment-input-6" placeholder="输入评论">
                    <button class="comment-button" onclick="addComment(6)">提交评论</button>
                    <ul class="comment-list" id="comment-list-6"></ul>
                </div>
                </div>
                
                <div class="literature-item" style="background-color: #fff;">
                <h2>Topology-Aware Block Coordinate Descent for Qubit Frequency Calibration of Superconducting Quantum Processors</h2>
                <div class="authors">Zheng Zhao, Weifeng Zhuang, Yanwu Gu, Peng Qian, Xiao Xiao, Dong E. Liu</div>
                <div class="summary">
                摘要：预执行校准是操作超导量子处理器的一个主要瓶颈，尤其是在qubit频率分配方面，由于交叉谈耦合的目标，这是一个特别具有挑战性的问题。我们证明了广泛使用的Snake优化器在数学上与块坐标下降（BCD）等效，为这种校准策略提供了坚实的理论基础。在这一形式化基础上，我们提出了一种基于拓扑的块排序，该排序通过将顺序选择转换为依赖序列的旅行商问题（SD-TSP）并使用邻近邻居启发式高效求解。SD-TSP的成本反映了给定块选择如何扩展用于评估块局部目标的缩减电路足迹，从而实现可以最小化每个epoch评估时间的排序。在局部交叉谈/有界度数假设下，该方法在每个epoch中实现线性复杂度（基于qubit数量），同时保持校准质量。我们形式化了校准目标，阐明缩减实验何时等效或近似于完整目标，并分析了含噪声测量的不精确BCD的收敛性。多qubit模型的模拟表明，所提出的基于BFS、DFS和随机排序（BFS, DFS）的图形启发式和随机顺序的BCD-NNA排序在同样的优化准确性的情况下运行时间大幅减少，并且能够容忍测量噪声和适度的非局部交叉谈。这些结果为NISQ时代处理器上的频率校准提供了可扩展且可实现的工作
                </div>
                <a href="https://arxiv.org/abs/2601.10203" class="link">https://arxiv.org/abs/2601.10203</a>
                <div class="comment-section">
                    <h3>评论</h3>
                    <input type="text" class="comment-input" id="comment-input-7" placeholder="输入评论">
                    <button class="comment-button" onclick="addComment(7)">提交评论</button>
                    <ul class="comment-list" id="comment-list-7"></ul>
                </div>
                </div>
                
                <div class="literature-item" style="background-color: #fff;">
                <h2>Noise-Resilient Quantum Evolution in Open Systems through Error-Correcting Frameworks</h2>
                <div class="authors">Nirupam Basak, Goutam Paul, Pritam Chattopadhyay</div>
                <div class="summary">
                摘要：我们分析了开放量子系统中使用显式嵌入到微观系统-浴模型中的量子纠错校正代码来保持量子态。研究考虑多量子比特寄存器与玻色热环境的耦合，导出二阶主方程，并用于基准测试五比特、Steane和马赛克码在局部和集体噪声下的性能。低温下，五比特码通过反复纠错明显抑制退相干，而高温下热激发降低了所有代码的效益，但五比特码仍优于其他码。此外，对两量子比特Werner态的研究确定了一个临界演化时间，在此之前纠错不会提高保真度，之后则有所改善。这些发现为在实际噪声环境中评估和开发抗噪声的量子架构提供了指导。
                </div>
                <a href="https://arxiv.org/abs/2601.10206" class="link">https://arxiv.org/abs/2601.10206</a>
                <div class="comment-section">
                    <h3>评论</h3>
                    <input type="text" class="comment-input" id="comment-input-8" placeholder="输入评论">
                    <button class="comment-button" onclick="addComment(8)">提交评论</button>
                    <ul class="comment-list" id="comment-list-8"></ul>
                </div>
                </div>
                
                <div class="literature-item" style="background-color: #fff;">
                <h2>Coherence Limits in Interference-Based cos(2$φ$) Qubits</h2>
                <div class="authors">S. Messelot, A. Leblanc, J.-S. Tettekpoe, F. Lefloch, Q. Ficheux, J. Renard, É. Dumur</div>
                <div class="summary">
                摘要：We investigate the coherence properties of parity-protected $\cos(2\varphi)$ qubits based on interferences between two Josephson elements in a superconducting loop. We show that qubit implementations of a $\cos(2\varphi)$ potential using a single loop, such as those employing semiconducting junctions, rhombus circuits, flowermon and KITE structures, can be described by the same Hamiltonian as two multi-harmonic Josephson junctions in a SQUID geometry. We find that, despite the parity protection arising from the suppression of single Cooper pair tunneling, there exists a fundamental trade-off between charge and flux noise dephasing channels. Using numerical simulations, we examine how relaxation and dephasing rates depend on external flux and circuit parameters, and we identify the best compromise for maximum coherence. With currently existing circuit parameters, the qubit lifetime $T_1$ can exceed milliseconds while the dephasing time $T_\varphi$ remains limited to only a few microseconds due to either flux or charge noise. Our findings establish practical limits on the coherence of this class of qubits and raise questions about the long-term potential of this approach
                </div>
                <a href="https://arxiv.org/abs/2601.10209" class="link">https://arxiv.org/abs/2601.10209</a>
                <div class="comment-section">
                    <h3>评论</h3>
                    <input type="text" class="comment-input" id="comment-input-9" placeholder="输入评论">
                    <button class="comment-button" onclick="addComment(9)">提交评论</button>
                    <ul class="comment-list" id="comment-list-9"></ul>
                </div>
                </div>
                
                <div class="literature-item" style="background-color: #fff;">
                <h2>Optimal control of a dissipative micromaser quantum battery in the ultrastrong coupling regime</h2>
                <div class="authors">Maristella Crotti, Luca Razzoli, Luigi Giannelli, Giuseppe A. Falci, Giuliano Benenti</div>
                <div class="summary">
                摘要：我们研究了一个在超强耦合（USC） режим下工作的微型量子电池在开系统动力学中的行为，该系统受到环境去相干的影响。该电池由一个单模电磁腔体构成，通过Rabi哈密顿量与一串充电器qubits依次相互作用。由于子-腔体系统与热浴之间存在弱耦合，因此会产生去相干效应。在USC режим中，反旋转项的影响不容忽视，它们显著提高了充电速度，但在没有去相干的情况下，也导致了能量的无界增长和腔体状态的高度混合。每次qubit-腔体相互作用期间的去相干缓解了这些有害效应，产生了有限能量和均能动量的稳态。通过对qubit准备和相互作用时间的最优控制，可以提高电池性能：（i）通过优化充电协议最大化存储的均能动量；（ii）通过基于测量的主动反馈策略优化，稳定存储的均能动量以抵消去相干损失。总体而言，我们的数值结果表明，超强光物质耦合、受控去相干和优化控制策略之间的相互作用，使得微型maser量子电池在现实条件下能够实现更高的充电性能和长期稳定性。
                </div>
                <a href="https://arxiv.org/abs/2601.10281" class="link">https://arxiv.org/abs/2601.10281</a>
                <div class="comment-section">
                    <h3>评论</h3>
                    <input type="text" class="comment-input" id="comment-input-10" placeholder="输入评论">
                    <button class="comment-button" onclick="addComment(10)">提交评论</button>
                    <ul class="comment-list" id="comment-list-10"></ul>
                </div>
                </div>
                
                <div class="literature-item" style="background-color: #fff;">
                <h2>Learning Hamiltonians in the Heisenberg limit with static single-qubit fields</h2>
                <div class="authors">Shrigyan Brahmachari, Shuchen Zhu, Iman Marvian, Yu Tong</div>
                <div class="summary">
                摘要：学习控制量子系统的哈密顿量是在量子测量学、量子传感和设备表征中的核心任务。现有的海森堡极限哈密顿量学习协议要么需要易受噪声影响的多量子比特操作，要么需要单量子比特操作，其频率或强度随着所需精度的提高而增加。这两个要求限制了哈密顿量学习在近期量子平台上的应用。我们提出了一种协议，仅使用静态场形式的单量子比特控制，以优化的海森堡极限缩放来学习量子哈密顿量，其强度与目标精度无关。我们的协议对状态准备和测量（SPAM）错误具有鲁棒性。通过克服这些限制，我们的协议为设备表征和量子传感提供了新的工具。我们通过严格的数学证明和数值实验展示了我们的方法达到了海森堡极限缩放。我们还证明了一个信息论下界，表明除非采用大量离散控制操作，否则需要非零静态场强度才能达到海森堡极限。
                </div>
                <a href="https://arxiv.org/abs/2601.10380" class="link">https://arxiv.org/abs/2601.10380</a>
                <div class="comment-section">
                    <h3>评论</h3>
                    <input type="text" class="comment-input" id="comment-input-11" placeholder="输入评论">
                    <button class="comment-button" onclick="addComment(11)">提交评论</button>
                    <ul class="comment-list" id="comment-list-11"></ul>
                </div>
                </div>
                
                <div class="literature-item" style="background-color: #fff;">
                <h2>Experimental Realization of Rabi-Driven Reset for Fast Cooling of a High-Q Cavity</h2>
                <div class="authors">Eliya Blumenthal, Natan Karaev, Shay Hacohen-Gourgy</div>
                <div class="summary">
                
                </div>
                <a href="https://arxiv.org/abs/2601.10385" class="link">https://arxiv.org/abs/2601.10385</a>
                <div class="comment-section">
                    <h3>评论</h3>
                    <input type="text" class="comment-input" id="comment-input-12" placeholder="输入评论">
                    <button class="comment-button" onclick="addComment(12)">提交评论</button>
                    <ul class="comment-list" id="comment-list-12"></ul>
                </div>
                </div>
                
                <div class="literature-item" style="background-color: #fff;">
                <h2>The SpinPulse library for transpilation and noise-accurate simulation of spin qubit quantum computers</h2>
                <div class="authors">Benoît Vermersch, Oscar Gravier, Nathan Miscopein, Julia Guignon, Carlos Ramos Marimón, Jonathan Durandau, Matthieu Dartiailh, Tristan Meunier, Valentin Savin</div>
                <div class="summary">
                摘要：我们介绍了SpinPulse，这是一个开源的Python包，用于模拟基于自旋量子比特的量子计算机，在脉冲级别上进行建模。SpinPulse模型模拟了自旋量子比特的具体物理特性，特别是通过包含经典非马尔可夫噪声。这样可以实现对本地门和量子电路的真实模拟，以支持硬件开发。在SpinPulse中，一个量子电路首先被翻译成我们的模型的本地门集，然后转换为脉冲序列。随后，该脉冲序列在模拟的有噪声实验环境中进行数值积分。我们展示了包括编译、脉冲级别编译、硬件基准测试、量子误差缓解和通过与张量网络库quimb集成的大规模模拟在内的一些工作流程。我们期望SpinPulse将成为一个有价值的开源工具，为量子计算社区促进高保真度量子电路的设计和改进量子误差缓解和纠正策略的努力。
                </div>
                <a href="https://arxiv.org/abs/2601.10435" class="link">https://arxiv.org/abs/2601.10435</a>
                <div class="comment-section">
                    <h3>评论</h3>
                    <input type="text" class="comment-input" id="comment-input-13" placeholder="输入评论">
                    <button class="comment-button" onclick="addComment(13)">提交评论</button>
                    <ul class="comment-list" id="comment-list-13"></ul>
                </div>
                </div>
                
                <div class="literature-item" style="background-color: #fff;">
                <h2>Minimal-Energy Optimal Control of Tunable Two-Qubit Gates in Superconducting Platforms Using Continuous Dynamical Decoupling</h2>
                <div class="authors">Adonai Hilário da Silva, Octávio da Motta, Leonardo Kleber Castelano, Reginaldo de Jesus Napolitano</div>
                <div class="summary">
                摘要：我们提出了一种在超导平台上通过持续动态去耦合（CDD）结合变分最小能量优化控制来生成高保真纠缠门的统一方案。在 CDD 阶段，我们抑制了残余耦合、校准漂移和准静噪声，得到一个稳定的有效哈密顿量，该哈密顿量保持设计用于产生可调谐耦合器的预期 ZZ 相互作用。在这个稳定的 SU(4) 流形中，我们使用变分几何优化过程计算光滑低能量单比特控制函数，该过程直接最小化门忠实度。我们通过应用这种方法来实现 CZ、CX 和一般纠缠门，展示了在限制的单比特操作下几乎单位保真度和健壮性，并使用了实验上现实的控制场。这些结果建立了 CDD 增强的变分几何优化控制作为设计超导纠缠门的实际且抗噪声方案。
                </div>
                <a href="https://arxiv.org/abs/2601.10446" class="link">https://arxiv.org/abs/2601.10446</a>
                <div class="comment-section">
                    <h3>评论</h3>
                    <input type="text" class="comment-input" id="comment-input-14" placeholder="输入评论">
                    <button class="comment-button" onclick="addComment(14)">提交评论</button>
                    <ul class="comment-list" id="comment-list-14"></ul>
                </div>
                </div>
                
                <div class="literature-item" style="background-color: #fff;">
                <h2>Erasure conversion for singlet-triplet spin qubits enables high-performance shuttling-based quantum error correction</h2>
                <div class="authors">Adam Siegel, Simon Benjamin</div>
                <div class="summary">
                摘要：在半导体量子点设备中，已经演示了自旋量子比特的快速高保真度传送。基于传送提出了几种架构；建议单双自旋（双自旋）量子比特可能是最高传送保真度的最佳选择。我们提出了一种基于此类双自旋量子比特的容错量子纠错码框架，将其确立为半导体架构中消除量子比特的自然实现。我们引入了一种硬件高效的泄漏检测协议，该协议会自动将泄漏的量子比特投影回计算子空间，无需测量反馈或增加经典控制开销。当与XZZX表面码和泄漏感知解码结合时，我们展示了错误纠正阈值提高了一倍，并在逻辑错误率上实现了数量级的降低。这确立了单双自旋编码作为半导体设备中高保真度传送和基于消除的容错量子计算的实际途
                </div>
                <a href="https://arxiv.org/abs/2601.10461" class="link">https://arxiv.org/abs/2601.10461</a>
                <div class="comment-section">
                    <h3>评论</h3>
                    <input type="text" class="comment-input" id="comment-input-15" placeholder="输入评论">
                    <button class="comment-button" onclick="addComment(15)">提交评论</button>
                    <ul class="comment-list" id="comment-list-15"></ul>
                </div>
                </div>
                
                <div class="literature-item" style="background-color: #fff;">
                <h2>Analysis and Experimental Demonstration of Amplitude Amplification for Combinatorial Optimization</h2>
                <div class="authors">Daniel Koch, Brian Pardo, Kip Nieman</div>
                <div class="summary">
                摘要：该研究扩展了Grover算法的传统二维表示，将其应用于编码QUBO等成本函数的Oracle，并展示了线性成本函数的特殊情况。通过模拟至多40个量子比特的问题，验证了算法性能，特别是在接近全局最优解时的表现。此外，在IBM Q（超导）和IonQ（捕获离子）上进行实验，结果与理论模型一致。
                </div>
                <a href="https://arxiv.org/abs/2601.10473" class="link">https://arxiv.org/abs/2601.10473</a>
                <div class="comment-section">
                    <h3>评论</h3>
                    <input type="text" class="comment-input" id="comment-input-16" placeholder="输入评论">
                    <button class="comment-button" onclick="addComment(16)">提交评论</button>
                    <ul class="comment-list" id="comment-list-16"></ul>
                </div>
                </div>
                
                <div class="literature-item" style="background-color: #fff;">
                <h2>Quantum Maxwell Erasure Decoder for qLDPC codes</h2>
                <div class="authors">Bruno Costa Alves Freire, François-Marie Le Régent, Anthony Leverrier</div>
                <div class="summary">
                摘要：我们介绍了一种用于CSS量子低密度奇偶校验（qLDPC）码的量子Maxwell擦除解码器，该解码器通过有限猜测来扩展剥离。猜测是以符号方式进行跟踪的，可以通过限制性检查消除，从而通过猜测预算在复杂度和性能之间实现可调节的权衡：无约束预算恢复最大似然（ML）性能，而固定预算提供线性时间解码并近似于ML。我们提供了渐近性能的理论保证，并展示了对双变量自行车代码和量子 Tanner 码的强劲性能。

最终判断是True。
</think>

摘要：我们介绍了一种用于CSS量子低密度奇偶校验（qLDPC）码的量子Maxwell擦除解码器，该解码器通过有限猜测来扩展剥离。猜测是以符号方式进行跟踪的，可以通过限制性检查消除，从而通过猜测预算在复杂度和性能之间实现可调节的权衡：无约束预算恢复最大似然（ML）性能，而固定预算提供线性时间解码并近似于ML。我们提供了渐近性能的理论保证，并展示了对双变量自行车代码和量子 Tanner 码的强劲性能。
                </div>
                <a href="https://arxiv.org/abs/2601.10713" class="link">https://arxiv.org/abs/2601.10713</a>
                <div class="comment-section">
                    <h3>评论</h3>
                    <input type="text" class="comment-input" id="comment-input-17" placeholder="输入评论">
                    <button class="comment-button" onclick="addComment(17)">提交评论</button>
                    <ul class="comment-list" id="comment-list-17"></ul>
                </div>
                </div>
                
                <div class="literature-item" style="background-color: #fff;">
                <h2>Emergent Nonperturbative Universal Floquet Localization</h2>
                <div class="authors">Soumadip Pakrashi, Atanu Rajak, Sambuddha Sanyal</div>
                <div class="summary">
                摘要：我们展示了一种在周期驱动的准周期光栅中出现的稳健、非微扰局域化平台，该平台独立于静态局域化特性和驱动协议。使用精确Floquet动力学、Floquet微扰理论和最优顺序van Vleck分析，我们确定了一种精细调谐幅度与频率比，其中所有Floquet状态都变得局域化，尽管存在稠密的共振。van Vleck展开在某个最佳顺序下达到了超渐近准确性，但最终由于弱准周期势垅间的共振杂交而崩溃，这表明观察到的局域化是非微扰的。
                </div>
                <a href="https://arxiv.org/abs/2601.09793" class="link">https://arxiv.org/abs/2601.09793</a>
                <div class="comment-section">
                    <h3>评论</h3>
                    <input type="text" class="comment-input" id="comment-input-18" placeholder="输入评论">
                    <button class="comment-button" onclick="addComment(18)">提交评论</button>
                    <ul class="comment-list" id="comment-list-18"></ul>
                </div>
                </div>
                
                <div class="literature-item" style="background-color: #fff;">
                <h2>Hybrid superinductance with Al/InAs</h2>
                <div class="authors">Junseok Oh, Ido Levy, Tyler Cowan, Jacob Issokson, Archana Kamal, Javad Shabani, Andrew P. Higginbotham</div>
                <div class="summary">
                摘要：我们报告了用分光镜技术对Al/InAs异质结构的约瑟夫森结链进行的研究。这些链体现出超电感抗特性，其波特性阻抗超过$R_{Q} = \hbar/(2e)^{2}$。结的平面结构导致大等离子频率，在12 GHz以下没有观察到理想色散的偏差。随着频率增加，内部质量因数急剧下降，这可以用一个简单的损耗模型来描述。考虑了一种可能与超导-半导体结相关的固有损耗机制。
                </div>
                <a href="https://arxiv.org/abs/2601.10023" class="link">https://arxiv.org/abs/2601.10023</a>
                <div class="comment-section">
                    <h3>评论</h3>
                    <input type="text" class="comment-input" id="comment-input-19" placeholder="输入评论">
                    <button class="comment-button" onclick="addComment(19)">提交评论</button>
                    <ul class="comment-list" id="comment-list-19"></ul>
                </div>
                </div>
                
                <div class="literature-item" style="background-color: #fff;">
                <h2>Energy Landscape Structure of Small Graph Isomorphism Under Variational Optimization</h2>
                <div class="authors">Turbasu Chatterjee, Shah Ishmam Mohtashim, Akash Kundu</div>
                <div class="summary">
                摘要：我们研究了一种图同构问题的二次无约束二进制优化（QUBO）公式，使用了量子近似优化算法（QAOA）和变分量子特征值求解器（VQE）。对于小规模的图实例，我们观察到同构的图对在变分能量上表现出一致的聚类特征，这表明哈密顿量成功编码了结构特性。然而，我们证明单独依靠低变分能量来确认同构是不可靠的，因为很可能收敛到违反双射约束的不可行状态。为了解决这个问题，我们分析了优化轨迹而不是最终能量；与简单的能量阈值方法相比，表现出色，尽管绝对性能仍然有限。我们的结果表征了当前基于变分算法的图同构问题的限制，将能量景观分析定位为一种诊断工具，而非NISQ体制中可扩展的决策程序。
                </div>
                <a href="https://arxiv.org/abs/2111.09821" class="link">https://arxiv.org/abs/2111.09821</a>
                <div class="comment-section">
                    <h3>评论</h3>
                    <input type="text" class="comment-input" id="comment-input-20" placeholder="输入评论">
                    <button class="comment-button" onclick="addComment(20)">提交评论</button>
                    <ul class="comment-list" id="comment-list-20"></ul>
                </div>
                </div>
                
                <div class="literature-item" style="background-color: #fff;">
                <h2>Arbitrary Polynomial Separations in Trainable Quantum Machine Learning</h2>
                <div class="authors">Eric R. Anschuetz, Xun Gao</div>
                <div class="summary">
                摘要：最近在量子机器学习领域的理论研究表明，量子神经网络（QNNs）的表达能力和可训练性之间存在一种普遍的权衡关系；作为这些结果的推论，由于QNNs的训练时间随模型大小呈指数增长，因此认为它们在表达能力上对经典机器学习模型具有实用的指数分离被认为是不可能的。我们通过构建一个高效可训练的QNN层次结构来规避这些负面结果，这些QNNs在执行经典序列建模任务时表现出可以无条件证明的、多项式内存分离，且常数度可以任意设置—包括对state-of-the-art模型（如Transformers）的分离。该构造在计算上也是高效的，因为引入的QNNs类中的每个单元细胞仅具有恒定的门电路复杂度。我们表明，情境性——非正式地，它是一种语义模糊性的定量概念——是表达分离的来源，这表明其他具有此属性的学习任务可能是使用量子学习算法的自然场景。
                </div>
                <a href="https://arxiv.org/abs/2402.08606" class="link">https://arxiv.org/abs/2402.08606</a>
                <div class="comment-section">
                    <h3>评论</h3>
                    <input type="text" class="comment-input" id="comment-input-21" placeholder="输入评论">
                    <button class="comment-button" onclick="addComment(21)">提交评论</button>
                    <ul class="comment-list" id="comment-list-21"></ul>
                </div>
                </div>
                
                <div class="literature-item" style="background-color: #fff;">
                <h2>Assessing fault-tolerant quantum advantage for $k$-SAT with structure</h2>
                <div class="authors">Martijn Brehm, Jordi Weggemans</div>
                <div class="summary">
                摘要：对于许多问题，量子算法比经典算法有速度优势。然而，这些结果主要依赖于渐近最坏情况分析，这忽略了由于纠错和实际实例通常包含可利用结构所带来的大量开销。在这项工作中，我们采用混合基准测试方法评估量子回溯算法和Grov算法在解决具有可调节结构的随机k-SAT实例（代表工业_like场景）中的潜力，使用T_depth和T_count作为成本指标来估计量子运行时间。我们的研究结果在无结构的情况下使用混合基准测试重现了Campbell、Khurana和Montanaro（Quantum '19）的结果。然而，我们提供了一种更为清醒的视角，实际相关情况：几乎所有的量子速度优势都消失，即使是渐近情况下，当引入最小结构或考虑T_count而不是T_depth时。此外，当要求算法在一天内找到解决方案时，我们发现只有Grov算法有潜力超越经典算法，但仅限于非常有限的领域，并且仅在使用T_depth时。我们还讨论了如何更复杂的启发式方法可以恢复量子回溯的渐近缩放优势，但我们的研究结果表明，在更结构化的k-SAT求解中，实际量子速度提升的潜力将仍然受到限制。
                </div>
                <a href="https://arxiv.org/abs/2412.13274" class="link">https://arxiv.org/abs/2412.13274</a>
                <div class="comment-section">
                    <h3>评论</h3>
                    <input type="text" class="comment-input" id="comment-input-22" placeholder="输入评论">
                    <button class="comment-button" onclick="addComment(22)">提交评论</button>
                    <ul class="comment-list" id="comment-list-22"></ul>
                </div>
                </div>
                
                <div class="literature-item" style="background-color: #fff;">
                <h2>Entropy Density Benchmarking of Near-Term Quantum Circuits</h2>
                <div class="authors">Marine Demarty, James Mills, Kenza Hammam, Raul Garcia-Patron</div>
                <div class="summary">
                摘要：理解噪声对当前及下一代量子设备的限制是实现实际量子优势的关键一步。本研究中，我们将熵密度积累作为性能基准来监测量子处理单元（QPU）的表现。我们展示了新方法的原理证明，该方法包括开发简单的启发式模型以模拟熵密度如何积累，测试这些模型与真实QPU实验，并最终利用这些模型确定电路体积阈值，以判断是否能够实现量子优势。监测熵密度不仅提供了一种新颖的方法来补充现有的电路级基准测试技术，更重要的是，它连接了电路级和应用级基准协议之间的差距。特别是，我们对熵积累的启发式模型使我们能够超越现有技术，这些技术为实现量子优势所需的电路尺寸设定了限制。
                </div>
                <a href="https://arxiv.org/abs/2412.18007" class="link">https://arxiv.org/abs/2412.18007</a>
                <div class="comment-section">
                    <h3>评论</h3>
                    <input type="text" class="comment-input" id="comment-input-23" placeholder="输入评论">
                    <button class="comment-button" onclick="addComment(23)">提交评论</button>
                    <ul class="comment-list" id="comment-list-23"></ul>
                </div>
                </div>
                
                <div class="literature-item" style="background-color: #fff;">
                <h2>Protected phase gate for the $0$-$π$ qubit using its internal modes</h2>
                <div class="authors">Xanda C Kolesnikow, Thomas B Smith, Felix Thomsen, Abhijeet Alase, Andrew C Doherty</div>
                <div class="summary">
                摘要：受保护的超导量子比特，如0-π量子比特，有望大幅降低物理误差率。然而，当前领域的一个关键挑战是设计适用于这些量子比特且不会损害其保护或在提高量子比特保护时变得不切实际缓慢的逻辑门。在这项研究中，我们提出了一种兼容受保护0-π量子比特受保护模式的受保护相位门，并且不会因误导耦合到额外的电路模式而受到影响。我们的门利用电路的一个内部模式作为辅助，通过可调谐约瑟夫森元件改变量子比特与辅助的耦合来实现。通过数值模拟，我们研究了门错误如何随着0-π量子比特和实现门的可调谐约瑟夫森元件的电路参数而变化。最终，我们发现利用近期的电路参数，受保护的0-π量子比特逻辑门是可能的。这项工作开辟了在受保护超导量子比特上执行受保护逻辑门的可能性，这可能会大幅减少量子计算的硬件开销。
                </div>
                <a href="https://arxiv.org/abs/2503.14634" class="link">https://arxiv.org/abs/2503.14634</a>
                <div class="comment-section">
                    <h3>评论</h3>
                    <input type="text" class="comment-input" id="comment-input-24" placeholder="输入评论">
                    <button class="comment-button" onclick="addComment(24)">提交评论</button>
                    <ul class="comment-list" id="comment-list-24"></ul>
                </div>
                </div>
                
                <div class="literature-item" style="background-color: #fff;">
                <h2>Quantum circuit complexity and unsupervised machine learning of topological order</h2>
                <div class="authors">Yanming Che, Clemens Gneiting, Xiaoguang Wang, Franco Nori</div>
                <div class="summary">
                摘要：受Kolmogorov复杂度与无监督机器学习之间密切关系的启发，我们探索了量子电路复杂性——这一在量子计算和量子信息科学中重要的概念，作为理解和构建可解释且高效的用于量子多体系统拓扑相的无监督机器学习的支点。我们认为Nielsen的量子电路复杂性代表了拓扑量子多体相之间的固有拓扑距离，并因此在可解释的拓扑相流形学习中起到核心作用。为了将概念上的强大功能与实际应用联系起来，我们提出了两个定理，分别连接了Nielsen的量子电路复杂性与量子费希尔复杂度（Bures距离）和纠缠生成，从而制定了更实用的基于保真度和纠缠的相似度量或核函数。利用这两个提出的距离测量方法，对键合交替XXZ自旋链、Kitaev经纬码的地面态以及随机产物态进行了拓扑相无监督流形学习，展示了其优越性能。此外，我们发现捕捉拓扑相长程结构的基于纠缠的方法更能抵抗局部Haar随机噪声。还讨论了与经典影子断层摄影和影子核学习的关系，其中后者可以从我们的方法中自然理解。我们的结果确立了量子电路计算、量子复杂度、量子计量学和拓扑量子相机器学习之间关键概念和工具的联系。
                </div>
                <a href="https://arxiv.org/abs/2508.04486" class="link">https://arxiv.org/abs/2508.04486</a>
                <div class="comment-section">
                    <h3>评论</h3>
                    <input type="text" class="comment-input" id="comment-input-25" placeholder="输入评论">
                    <button class="comment-button" onclick="addComment(25)">提交评论</button>
                    <ul class="comment-list" id="comment-list-25"></ul>
                </div>
                </div>
                
                <div class="literature-item" style="background-color: #fff;">
                <h2>Fast Bosonic Control via Multiphoton Qubit-Oscillator Interactions</h2>
                <div class="authors">Noah Gorgichuk, Mohammad Ayyash, Matteo Mariantoni, Sahel Ashhab</div>
                <div class="summary">
                摘要：我们提出了一种准备具有n倍旋转对称性振荡器态的协议，这些态包括许多用于玻色量子纠错码的逻辑码字。该协议依赖于振荡器与辅助qubit之间的多光子相互作用。此外，我们通过使用不同阶的多光子相互作用组合，实现了对振荡器希尔伯特空间的任意控制。我们还讨论了使用广义协议变体准备具有旋转对称性的多振荡器态。我们展示了多光子qubit-振荡器相互作用可以大幅减少态准备时间，与通常使用的线性qubit-振荡器相互作用相比。此外，我们进行了数值模拟，考虑了解体和振荡器的放松和去相位，使用真实的平面超导电路参数来验证我们的协议的稳健性。我们的发现可以显著提高玻色码在计划中的超导硬件上的性能，这对于可扩展的容错超导量子计算机来说几乎是必需
                </div>
                <a href="https://arxiv.org/abs/2510.27035" class="link">https://arxiv.org/abs/2510.27035</a>
                <div class="comment-section">
                    <h3>评论</h3>
                    <input type="text" class="comment-input" id="comment-input-26" placeholder="输入评论">
                    <button class="comment-button" onclick="addComment(26)">提交评论</button>
                    <ul class="comment-list" id="comment-list-26"></ul>
                </div>
                </div>
                
                <div class="literature-item" style="background-color: #fff;">
                <h2>Scheduling Lattice Surgery with Magic State Cultivation</h2>
                <div class="authors">Steven Hofmeyr, Mathias Weiden, Justin Kalloor, John Kubiatowicz, Costin Iancu</div>
                <div class="summary">
                摘要：容错量子计算利用表面码依赖高效的非Clifford运算调度，这些运算通过一种主导空间时间成本的概率过程生成魔法态来实现。现有的调度方法使用专用的总线量子比特进行路由，并且使用单独的外围辅助量子比特工厂准备魔法态，导致资源利用效率低下。随着魔法态培育方法的出现，准备量子比特可以放置在表面码架构的任何位置。我们引入了纯魔法调度，它动态地将魔法态培育量子比特重新用于路由操作，消除了专用的总线基础设施。通过在需要路由时中断培育过程，Pure Magic自然倾向于较短的培育时间，同时确保没有辅助量子比特处于空闲状态。我们对17个基准电路的评估显示，与传统的总线路由相比，调度效率提高了19%到223%，平均魔法态准备时间减少了2.6倍至9.7倍。随着电路并行度的增加，Pure Magic的优势在高度并行的量子算法中尤为明显。Pure Magic架构从静态到动态、按需驱动的调度代表了一个范式转换。
                </div>
                <a href="https://arxiv.org/abs/2512.06484" class="link">https://arxiv.org/abs/2512.06484</a>
                <div class="comment-section">
                    <h3>评论</h3>
                    <input type="text" class="comment-input" id="comment-input-27" placeholder="输入评论">
                    <button class="comment-button" onclick="addComment(27)">提交评论</button>
                    <ul class="comment-list" id="comment-list-27"></ul>
                </div>
                </div>
                
                <div class="literature-item" style="background-color: #fff;">
                <h2>Reservoir-Engineered Refrigeration of a Superconducting Cavity with Double-Quantum-Dot Spin Qubits</h2>
                <div class="authors">Daryoosh Vashaee, Jahanfar Abouie</div>
                <div class="summary">
                摘要：我们提出了一种可分析的储层工程冷却超导微波腔的理论，并将其映射到基于门定义双量子点（DQD）自旋量子比特的实际固态实现中。通过将DQD不作为光谱学元件而是可调节的工程储层来处理，我们展示了如何通过门控控制人口、相干性、线宽和偏离来定义一个具有可预测详细平衡的有效光子产生-消亡过程。此框架得出封闭形式的腔稳态表达式，识别了冷却边界和与偏离相关的冷却谷，并阐明了在什么情况下冷却可以使腔温低于浴温和DQD设定值。通过区分刷新（碰撞类）和持久储层政权，我们展示了如何记忆效应、饱和和暗态形成约束实际设备的冷却，而双点配置中的集体明模式耦合可以增强冷却受错配和去相位影响，为数值Lindblad模拟所证实的针对cryogenic circuit-QED架构的目标毫开尔文腔冷却。
                </div>
                <a href="https://arxiv.org/abs/2601.09516" class="link">https://arxiv.org/abs/2601.09516</a>
                <div class="comment-section">
                    <h3>评论</h3>
                    <input type="text" class="comment-input" id="comment-input-28" placeholder="输入评论">
                    <button class="comment-button" onclick="addComment(28)">提交评论</button>
                    <ul class="comment-list" id="comment-list-28"></ul>
                </div>
                </div>
                
                <div class="literature-item" style="background-color: #fff;">
                <h2>Localization with non-Hermitian off-diagonal disorder</h2>
                <div class="authors">Aitijhya Saha, Debraj Rakshit</div>
                <div class="summary">
                摘要：在这项工作中，我们通过一个一维单粒子的紧束绑模型讨论了一个非厄米系统，其中非厄米性由随机最近邻隧道控制，使得左侧到右侧和右侧到左侧的跳跃强度不相等。由于哈密顿量在简单的符号保存下具有三对角矩阵结构，因此会出现完全实数本征谱的一种物理情况。非对角线无序导致有限系统中的去局域化-局域化过渡。通过有限尺寸的谱分析，人们认识到这种过渡的新兴性质。在热力学极限下，对于无穷小的无序强度，系统会进入局域化阶段。我们对局域化长度、逆参与率(IPR)和能量分裂进行了仔细的尺度分析，并报告了相应的尺度指数。值得注意的是，与对角线无序不同，在存在非对角线无序时，密度态谱(DOS)在E=0处具有奇异性，并且对于任何给定的无序强度，对应的波函数保持去局域化状态。
                </div>
                <a href="https://arxiv.org/abs/2310.13744" class="link">https://arxiv.org/abs/2310.13744</a>
                <div class="comment-section">
                    <h3>评论</h3>
                    <input type="text" class="comment-input" id="comment-input-29" placeholder="输入评论">
                    <button class="comment-button" onclick="addComment(29)">提交评论</button>
                    <ul class="comment-list" id="comment-list-29"></ul>
                </div>
                </div>
                
                <div class="literature-item" style="background-color: #fff;">
                <h2>Rydberg Atomic Quantum Receivers for Classical Wireless Communications and Sensing: Their Models and Performance</h2>
                <div class="authors">Tierui Gong, Jiaming Sun, Chau Yuen, Guangwei Hu, Yufei Zhao, Yong Liang Guan, Chong Meng Samson See, Mérouane Debbah, Lajos Hanzo</div>
                <div class="summary">
                
                </div>
                <a href="https://arxiv.org/abs/2412.05554" class="link">https://arxiv.org/abs/2412.05554</a>
                <div class="comment-section">
                    <h3>评论</h3>
                    <input type="text" class="comment-input" id="comment-input-30" placeholder="输入评论">
                    <button class="comment-button" onclick="addComment(30)">提交评论</button>
                    <ul class="comment-list" id="comment-list-30"></ul>
                </div>
                </div>
                
        <script>
        function addComment(paperIndex) {
            const commentInput = document.getElementById(`comment-input-${paperIndex}`);
            const commentText = commentInput.value;
            if (commentText) {
                const commentList = document.getElementById(`comment-list-${paperIndex}`);
                const now = new Date();
                const timestamp = now.toLocaleString();
                const newComment = document.createElement('li');
                newComment.textContent = `${timestamp}: ${commentText}`;
                commentList.appendChild(newComment);
                // 保存评论到本地存储
                let comments = JSON.parse(localStorage.getItem(`comments-${paperIndex}`)) || [];
                comments.push(`${timestamp}: ${commentText}`);
                localStorage.setItem(`comments-${paperIndex}`, JSON.stringify(comments));
                commentInput.value = '';
            }
        }
        
        // 页面加载时显示本地存储的评论
        window.onload = function () {
            const comments0 = JSON.parse(localStorage.getItem(`comments-0`)) || []; const commentList0 = document.getElementById(`comment-list-0`); comments0.forEach(comment => { const newComment = document.createElement('li'); newComment.textContent = comment; commentList0.appendChild(newComment); });const comments1 = JSON.parse(localStorage.getItem(`comments-1`)) || []; const commentList1 = document.getElementById(`comment-list-1`); comments1.forEach(comment => { const newComment = document.createElement('li'); newComment.textContent = comment; commentList1.appendChild(newComment); });const comments2 = JSON.parse(localStorage.getItem(`comments-2`)) || []; const commentList2 = document.getElementById(`comment-list-2`); comments2.forEach(comment => { const newComment = document.createElement('li'); newComment.textContent = comment; commentList2.appendChild(newComment); });const comments3 = JSON.parse(localStorage.getItem(`comments-3`)) || []; const commentList3 = document.getElementById(`comment-list-3`); comments3.forEach(comment => { const newComment = document.createElement('li'); newComment.textContent = comment; commentList3.appendChild(newComment); });const comments4 = JSON.parse(localStorage.getItem(`comments-4`)) || []; const commentList4 = document.getElementById(`comment-list-4`); comments4.forEach(comment => { const newComment = document.createElement('li'); newComment.textContent = comment; commentList4.appendChild(newComment); });const comments5 = JSON.parse(localStorage.getItem(`comments-5`)) || []; const commentList5 = document.getElementById(`comment-list-5`); comments5.forEach(comment => { const newComment = document.createElement('li'); newComment.textContent = comment; commentList5.appendChild(newComment); });const comments6 = JSON.parse(localStorage.getItem(`comments-6`)) || []; const commentList6 = document.getElementById(`comment-list-6`); comments6.forEach(comment => { const newComment = document.createElement('li'); newComment.textContent = comment; commentList6.appendChild(newComment); });const comments7 = JSON.parse(localStorage.getItem(`comments-7`)) || []; const commentList7 = document.getElementById(`comment-list-7`); comments7.forEach(comment => { const newComment = document.createElement('li'); newComment.textContent = comment; commentList7.appendChild(newComment); });const comments8 = JSON.parse(localStorage.getItem(`comments-8`)) || []; const commentList8 = document.getElementById(`comment-list-8`); comments8.forEach(comment => { const newComment = document.createElement('li'); newComment.textContent = comment; commentList8.appendChild(newComment); });const comments9 = JSON.parse(localStorage.getItem(`comments-9`)) || []; const commentList9 = document.getElementById(`comment-list-9`); comments9.forEach(comment => { const newComment = document.createElement('li'); newComment.textContent = comment; commentList9.appendChild(newComment); });const comments10 = JSON.parse(localStorage.getItem(`comments-10`)) || []; const commentList10 = document.getElementById(`comment-list-10`); comments10.forEach(comment => { const newComment = document.createElement('li'); newComment.textContent = comment; commentList10.appendChild(newComment); });const comments11 = JSON.parse(localStorage.getItem(`comments-11`)) || []; const commentList11 = document.getElementById(`comment-list-11`); comments11.forEach(comment => { const newComment = document.createElement('li'); newComment.textContent = comment; commentList11.appendChild(newComment); });const comments12 = JSON.parse(localStorage.getItem(`comments-12`)) || []; const commentList12 = document.getElementById(`comment-list-12`); comments12.forEach(comment => { const newComment = document.createElement('li'); newComment.textContent = comment; commentList12.appendChild(newComment); });const comments13 = JSON.parse(localStorage.getItem(`comments-13`)) || []; const commentList13 = document.getElementById(`comment-list-13`); comments13.forEach(comment => { const newComment = document.createElement('li'); newComment.textContent = comment; commentList13.appendChild(newComment); });const comments14 = JSON.parse(localStorage.getItem(`comments-14`)) || []; const commentList14 = document.getElementById(`comment-list-14`); comments14.forEach(comment => { const newComment = document.createElement('li'); newComment.textContent = comment; commentList14.appendChild(newComment); });const comments15 = JSON.parse(localStorage.getItem(`comments-15`)) || []; const commentList15 = document.getElementById(`comment-list-15`); comments15.forEach(comment => { const newComment = document.createElement('li'); newComment.textContent = comment; commentList15.appendChild(newComment); });const comments16 = JSON.parse(localStorage.getItem(`comments-16`)) || []; const commentList16 = document.getElementById(`comment-list-16`); comments16.forEach(comment => { const newComment = document.createElement('li'); newComment.textContent = comment; commentList16.appendChild(newComment); });const comments17 = JSON.parse(localStorage.getItem(`comments-17`)) || []; const commentList17 = document.getElementById(`comment-list-17`); comments17.forEach(comment => { const newComment = document.createElement('li'); newComment.textContent = comment; commentList17.appendChild(newComment); });const comments18 = JSON.parse(localStorage.getItem(`comments-18`)) || []; const commentList18 = document.getElementById(`comment-list-18`); comments18.forEach(comment => { const newComment = document.createElement('li'); newComment.textContent = comment; commentList18.appendChild(newComment); });const comments19 = JSON.parse(localStorage.getItem(`comments-19`)) || []; const commentList19 = document.getElementById(`comment-list-19`); comments19.forEach(comment => { const newComment = document.createElement('li'); newComment.textContent = comment; commentList19.appendChild(newComment); });const comments20 = JSON.parse(localStorage.getItem(`comments-20`)) || []; const commentList20 = document.getElementById(`comment-list-20`); comments20.forEach(comment => { const newComment = document.createElement('li'); newComment.textContent = comment; commentList20.appendChild(newComment); });const comments21 = JSON.parse(localStorage.getItem(`comments-21`)) || []; const commentList21 = document.getElementById(`comment-list-21`); comments21.forEach(comment => { const newComment = document.createElement('li'); newComment.textContent = comment; commentList21.appendChild(newComment); });const comments22 = JSON.parse(localStorage.getItem(`comments-22`)) || []; const commentList22 = document.getElementById(`comment-list-22`); comments22.forEach(comment => { const newComment = document.createElement('li'); newComment.textContent = comment; commentList22.appendChild(newComment); });const comments23 = JSON.parse(localStorage.getItem(`comments-23`)) || []; const commentList23 = document.getElementById(`comment-list-23`); comments23.forEach(comment => { const newComment = document.createElement('li'); newComment.textContent = comment; commentList23.appendChild(newComment); });const comments24 = JSON.parse(localStorage.getItem(`comments-24`)) || []; const commentList24 = document.getElementById(`comment-list-24`); comments24.forEach(comment => { const newComment = document.createElement('li'); newComment.textContent = comment; commentList24.appendChild(newComment); });const comments25 = JSON.parse(localStorage.getItem(`comments-25`)) || []; const commentList25 = document.getElementById(`comment-list-25`); comments25.forEach(comment => { const newComment = document.createElement('li'); newComment.textContent = comment; commentList25.appendChild(newComment); });const comments26 = JSON.parse(localStorage.getItem(`comments-26`)) || []; const commentList26 = document.getElementById(`comment-list-26`); comments26.forEach(comment => { const newComment = document.createElement('li'); newComment.textContent = comment; commentList26.appendChild(newComment); });const comments27 = JSON.parse(localStorage.getItem(`comments-27`)) || []; const commentList27 = document.getElementById(`comment-list-27`); comments27.forEach(comment => { const newComment = document.createElement('li'); newComment.textContent = comment; commentList27.appendChild(newComment); });const comments28 = JSON.parse(localStorage.getItem(`comments-28`)) || []; const commentList28 = document.getElementById(`comment-list-28`); comments28.forEach(comment => { const newComment = document.createElement('li'); newComment.textContent = comment; commentList28.appendChild(newComment); });const comments29 = JSON.parse(localStorage.getItem(`comments-29`)) || []; const commentList29 = document.getElementById(`comment-list-29`); comments29.forEach(comment => { const newComment = document.createElement('li'); newComment.textContent = comment; commentList29.appendChild(newComment); });const comments30 = JSON.parse(localStorage.getItem(`comments-30`)) || []; const commentList30 = document.getElementById(`comment-list-30`); comments30.forEach(comment => { const newComment = document.createElement('li'); newComment.textContent = comment; commentList30.appendChild(newComment); });
        };
        </script>
        </body>
        </html>
        